{"attributes":{"_arrays":{"A":{"attributes":{"_meta_allow_conflicts":{"category":"General","default":false,"desc":"","metatype":"bool"},"_meta_debuginfo":{"category":"General","default":{"end_column":0,"end_line":0,"filename":null,"start_column":0,"start_line":0,"type":"DebugInfo"},"desc":"","metatype":"DebugInfo"},"_meta_dtype":{"category":"General","default":"int32","desc":"","metatype":"typeclass"},"_meta_lifetime":{"category":"General","default":"Scope","desc":"Data allocation span","metatype":"AllocationLifetime"},"_meta_location":{"category":"General","default":{},"desc":"Full storage location identifier (e.g., rank, GPU ID)","metatype":"dict"},"_meta_shape":{"category":"General","default":[],"desc":"","metatype":"tuple"},"_meta_storage":{"category":"General","default":"Default","desc":"Storage location","metatype":"StorageType"},"_meta_transient":{"category":"General","default":false,"desc":"","metatype":"bool"},"allow_conflicts":false,"debuginfo":null,"dtype":"float64","lifetime":"Scope","location":{},"shape":["1"],"storage":"Default","transient":false},"type":"Scalar"},"X":{"attributes":{"_meta_alignment":{"category":"General","default":0,"desc":"Allocation alignment in bytes (0 uses compiler-default)","metatype":"int"},"_meta_allow_conflicts":{"category":"General","default":false,"desc":"If enabled, allows more than one memlet to write to the same memory location without conflict resolution.","metatype":"bool"},"_meta_debuginfo":{"category":"General","default":{"end_column":0,"end_line":0,"filename":null,"start_column":0,"start_line":0,"type":"DebugInfo"},"desc":"","metatype":"DebugInfo"},"_meta_dtype":{"category":"General","default":"int32","desc":"","metatype":"typeclass"},"_meta_lifetime":{"category":"General","default":"Scope","desc":"Data allocation span","metatype":"AllocationLifetime"},"_meta_location":{"category":"General","default":{},"desc":"Full storage location identifier (e.g., rank, GPU ID)","metatype":"dict"},"_meta_may_alias":{"category":"General","default":false,"desc":"This pointer may alias with other pointers in the same function","metatype":"bool"},"_meta_offset":{"category":"General","default":[],"desc":"Initial offset to translate all indices by.","metatype":"list"},"_meta_shape":{"category":"General","default":[],"desc":"","metatype":"tuple"},"_meta_storage":{"category":"General","default":"Default","desc":"Storage location","metatype":"StorageType"},"_meta_strides":{"category":"General","default":[],"desc":"For each dimension, the number of elements to skip in order to obtain the next element in that dimension.","metatype":"tuple"},"_meta_total_size":{"category":"General","default":1,"desc":"The total allocated size of the array. Can be used for padding.","metatype":"SymbolicProperty"},"_meta_transient":{"category":"General","default":false,"desc":"","metatype":"bool"},"alignment":0,"allow_conflicts":false,"debuginfo":null,"dtype":"float64","lifetime":"Scope","location":{},"may_alias":false,"offset":["0"],"shape":["N"],"storage":"Default","strides":["1"],"total_size":"N","transient":false},"type":"Array"},"X1":{"attributes":{"_meta_alignment":{"category":"General","default":0,"desc":"Allocation alignment in bytes (0 uses compiler-default)","metatype":"int"},"_meta_allow_conflicts":{"category":"General","default":false,"desc":"If enabled, allows more than one memlet to write to the same memory location without conflict resolution.","metatype":"bool"},"_meta_debuginfo":{"category":"General","default":{"end_column":0,"end_line":0,"filename":null,"start_column":0,"start_line":0,"type":"DebugInfo"},"desc":"","metatype":"DebugInfo"},"_meta_dtype":{"category":"General","default":"int32","desc":"","metatype":"typeclass"},"_meta_lifetime":{"category":"General","default":"Scope","desc":"Data allocation span","metatype":"AllocationLifetime"},"_meta_location":{"category":"General","default":{},"desc":"Full storage location identifier (e.g., rank, GPU ID)","metatype":"dict"},"_meta_may_alias":{"category":"General","default":false,"desc":"This pointer may alias with other pointers in the same function","metatype":"bool"},"_meta_offset":{"category":"General","default":[],"desc":"Initial offset to translate all indices by.","metatype":"list"},"_meta_shape":{"category":"General","default":[],"desc":"","metatype":"tuple"},"_meta_storage":{"category":"General","default":"Default","desc":"Storage location","metatype":"StorageType"},"_meta_strides":{"category":"General","default":[],"desc":"For each dimension, the number of elements to skip in order to obtain the next element in that dimension.","metatype":"tuple"},"_meta_total_size":{"category":"General","default":1,"desc":"The total allocated size of the array. Can be used for padding.","metatype":"SymbolicProperty"},"_meta_transient":{"category":"General","default":false,"desc":"","metatype":"bool"},"alignment":0,"allow_conflicts":false,"debuginfo":null,"dtype":"float64","lifetime":"Scope","location":{},"may_alias":false,"offset":["0"],"shape":["ceiling(N/2)"],"storage":"Default","strides":["1"],"total_size":"ceiling(N/2)","transient":true},"type":"Array"},"X2":{"attributes":{"_meta_alignment":{"category":"General","default":0,"desc":"Allocation alignment in bytes (0 uses compiler-default)","metatype":"int"},"_meta_allow_conflicts":{"category":"General","default":false,"desc":"If enabled, allows more than one memlet to write to the same memory location without conflict resolution.","metatype":"bool"},"_meta_debuginfo":{"category":"General","default":{"end_column":0,"end_line":0,"filename":null,"start_column":0,"start_line":0,"type":"DebugInfo"},"desc":"","metatype":"DebugInfo"},"_meta_dtype":{"category":"General","default":"int32","desc":"","metatype":"typeclass"},"_meta_lifetime":{"category":"General","default":"Scope","desc":"Data allocation span","metatype":"AllocationLifetime"},"_meta_location":{"category":"General","default":{},"desc":"Full storage location identifier (e.g., rank, GPU ID)","metatype":"dict"},"_meta_may_alias":{"category":"General","default":false,"desc":"This pointer may alias with other pointers in the same function","metatype":"bool"},"_meta_offset":{"category":"General","default":[],"desc":"Initial offset to translate all indices by.","metatype":"list"},"_meta_shape":{"category":"General","default":[],"desc":"","metatype":"tuple"},"_meta_storage":{"category":"General","default":"Default","desc":"Storage location","metatype":"StorageType"},"_meta_strides":{"category":"General","default":[],"desc":"For each dimension, the number of elements to skip in order to obtain the next element in that dimension.","metatype":"tuple"},"_meta_total_size":{"category":"General","default":1,"desc":"The total allocated size of the array. Can be used for padding.","metatype":"SymbolicProperty"},"_meta_transient":{"category":"General","default":false,"desc":"","metatype":"bool"},"alignment":0,"allow_conflicts":false,"debuginfo":null,"dtype":"float64","lifetime":"Scope","location":{},"may_alias":false,"offset":["0"],"shape":["ceiling(N/2)"],"storage":"Default","strides":["1"],"total_size":"ceiling(N/2)","transient":true},"type":"Array"},"Y":{"attributes":{"_meta_alignment":{"category":"General","default":0,"desc":"Allocation alignment in bytes (0 uses compiler-default)","metatype":"int"},"_meta_allow_conflicts":{"category":"General","default":false,"desc":"If enabled, allows more than one memlet to write to the same memory location without conflict resolution.","metatype":"bool"},"_meta_debuginfo":{"category":"General","default":{"end_column":0,"end_line":0,"filename":null,"start_column":0,"start_line":0,"type":"DebugInfo"},"desc":"","metatype":"DebugInfo"},"_meta_dtype":{"category":"General","default":"int32","desc":"","metatype":"typeclass"},"_meta_lifetime":{"category":"General","default":"Scope","desc":"Data allocation span","metatype":"AllocationLifetime"},"_meta_location":{"category":"General","default":{},"desc":"Full storage location identifier (e.g., rank, GPU ID)","metatype":"dict"},"_meta_may_alias":{"category":"General","default":false,"desc":"This pointer may alias with other pointers in the same function","metatype":"bool"},"_meta_offset":{"category":"General","default":[],"desc":"Initial offset to translate all indices by.","metatype":"list"},"_meta_shape":{"category":"General","default":[],"desc":"","metatype":"tuple"},"_meta_storage":{"category":"General","default":"Default","desc":"Storage location","metatype":"StorageType"},"_meta_strides":{"category":"General","default":[],"desc":"For each dimension, the number of elements to skip in order to obtain the next element in that dimension.","metatype":"tuple"},"_meta_total_size":{"category":"General","default":1,"desc":"The total allocated size of the array. Can be used for padding.","metatype":"SymbolicProperty"},"_meta_transient":{"category":"General","default":false,"desc":"","metatype":"bool"},"alignment":0,"allow_conflicts":false,"debuginfo":null,"dtype":"float64","lifetime":"Scope","location":{},"may_alias":false,"offset":["0"],"shape":["N"],"storage":"Default","strides":["1"],"total_size":"N","transient":false},"type":"Array"},"Y1":{"attributes":{"_meta_alignment":{"category":"General","default":0,"desc":"Allocation alignment in bytes (0 uses compiler-default)","metatype":"int"},"_meta_allow_conflicts":{"category":"General","default":false,"desc":"If enabled, allows more than one memlet to write to the same memory location without conflict resolution.","metatype":"bool"},"_meta_debuginfo":{"category":"General","default":{"end_column":0,"end_line":0,"filename":null,"start_column":0,"start_line":0,"type":"DebugInfo"},"desc":"","metatype":"DebugInfo"},"_meta_dtype":{"category":"General","default":"int32","desc":"","metatype":"typeclass"},"_meta_lifetime":{"category":"General","default":"Scope","desc":"Data allocation span","metatype":"AllocationLifetime"},"_meta_location":{"category":"General","default":{},"desc":"Full storage location identifier (e.g., rank, GPU ID)","metatype":"dict"},"_meta_may_alias":{"category":"General","default":false,"desc":"This pointer may alias with other pointers in the same function","metatype":"bool"},"_meta_offset":{"category":"General","default":[],"desc":"Initial offset to translate all indices by.","metatype":"list"},"_meta_shape":{"category":"General","default":[],"desc":"","metatype":"tuple"},"_meta_storage":{"category":"General","default":"Default","desc":"Storage location","metatype":"StorageType"},"_meta_strides":{"category":"General","default":[],"desc":"For each dimension, the number of elements to skip in order to obtain the next element in that dimension.","metatype":"tuple"},"_meta_total_size":{"category":"General","default":1,"desc":"The total allocated size of the array. Can be used for padding.","metatype":"SymbolicProperty"},"_meta_transient":{"category":"General","default":false,"desc":"","metatype":"bool"},"alignment":0,"allow_conflicts":false,"debuginfo":null,"dtype":"float64","lifetime":"Scope","location":{},"may_alias":false,"offset":["0"],"shape":["ceiling(N/2)"],"storage":"Default","strides":["1"],"total_size":"ceiling(N/2)","transient":true},"type":"Array"},"Y2":{"attributes":{"_meta_alignment":{"category":"General","default":0,"desc":"Allocation alignment in bytes (0 uses compiler-default)","metatype":"int"},"_meta_allow_conflicts":{"category":"General","default":false,"desc":"If enabled, allows more than one memlet to write to the same memory location without conflict resolution.","metatype":"bool"},"_meta_debuginfo":{"category":"General","default":{"end_column":0,"end_line":0,"filename":null,"start_column":0,"start_line":0,"type":"DebugInfo"},"desc":"","metatype":"DebugInfo"},"_meta_dtype":{"category":"General","default":"int32","desc":"","metatype":"typeclass"},"_meta_lifetime":{"category":"General","default":"Scope","desc":"Data allocation span","metatype":"AllocationLifetime"},"_meta_location":{"category":"General","default":{},"desc":"Full storage location identifier (e.g., rank, GPU ID)","metatype":"dict"},"_meta_may_alias":{"category":"General","default":false,"desc":"This pointer may alias with other pointers in the same function","metatype":"bool"},"_meta_offset":{"category":"General","default":[],"desc":"Initial offset to translate all indices by.","metatype":"list"},"_meta_shape":{"category":"General","default":[],"desc":"","metatype":"tuple"},"_meta_storage":{"category":"General","default":"Default","desc":"Storage location","metatype":"StorageType"},"_meta_strides":{"category":"General","default":[],"desc":"For each dimension, the number of elements to skip in order to obtain the next element in that dimension.","metatype":"tuple"},"_meta_total_size":{"category":"General","default":1,"desc":"The total allocated size of the array. Can be used for padding.","metatype":"SymbolicProperty"},"_meta_transient":{"category":"General","default":false,"desc":"","metatype":"bool"},"alignment":0,"allow_conflicts":false,"debuginfo":null,"dtype":"float64","lifetime":"Scope","location":{},"may_alias":false,"offset":["0"],"shape":["ceiling(N/2)"],"storage":"Default","strides":["1"],"total_size":"ceiling(N/2)","transient":true},"type":"Array"},"nested_slice_X_8_gpu_X":{"attributes":{"_meta_alignment":{"category":"General","default":0,"desc":"Allocation alignment in bytes (0 uses compiler-default)","metatype":"int"},"_meta_allow_conflicts":{"category":"General","default":false,"desc":"If enabled, allows more than one memlet to write to the same memory location without conflict resolution.","metatype":"bool"},"_meta_debuginfo":{"category":"General","default":{"end_column":0,"end_line":0,"filename":null,"start_column":0,"start_line":0,"type":"DebugInfo"},"desc":"","metatype":"DebugInfo"},"_meta_dtype":{"category":"General","default":"int32","desc":"","metatype":"typeclass"},"_meta_lifetime":{"category":"General","default":"Scope","desc":"Data allocation span","metatype":"AllocationLifetime"},"_meta_location":{"category":"General","default":{},"desc":"Full storage location identifier (e.g., rank, GPU ID)","metatype":"dict"},"_meta_may_alias":{"category":"General","default":false,"desc":"This pointer may alias with other pointers in the same function","metatype":"bool"},"_meta_offset":{"category":"General","default":[],"desc":"Initial offset to translate all indices by.","metatype":"list"},"_meta_shape":{"category":"General","default":[],"desc":"","metatype":"tuple"},"_meta_storage":{"category":"General","default":"Default","desc":"Storage location","metatype":"StorageType"},"_meta_strides":{"category":"General","default":[],"desc":"For each dimension, the number of elements to skip in order to obtain the next element in that dimension.","metatype":"tuple"},"_meta_total_size":{"category":"General","default":1,"desc":"The total allocated size of the array. Can be used for padding.","metatype":"SymbolicProperty"},"_meta_transient":{"category":"General","default":false,"desc":"","metatype":"bool"},"alignment":0,"allow_conflicts":false,"debuginfo":null,"dtype":"float64","lifetime":"Scope","location":{"gpu":"0"},"may_alias":false,"offset":["0"],"shape":["ceiling(N/2)"],"storage":"GPU_Global","strides":["1"],"total_size":"N","transient":true},"type":"Array"},"nested_slice_X_8_gpu_X_0":{"attributes":{"_meta_alignment":{"category":"General","default":0,"desc":"Allocation alignment in bytes (0 uses compiler-default)","metatype":"int"},"_meta_allow_conflicts":{"category":"General","default":false,"desc":"If enabled, allows more than one memlet to write to the same memory location without conflict resolution.","metatype":"bool"},"_meta_debuginfo":{"category":"General","default":{"end_column":0,"end_line":0,"filename":null,"start_column":0,"start_line":0,"type":"DebugInfo"},"desc":"","metatype":"DebugInfo"},"_meta_dtype":{"category":"General","default":"int32","desc":"","metatype":"typeclass"},"_meta_lifetime":{"category":"General","default":"Scope","desc":"Data allocation span","metatype":"AllocationLifetime"},"_meta_location":{"category":"General","default":{},"desc":"Full storage location identifier (e.g., rank, GPU ID)","metatype":"dict"},"_meta_may_alias":{"category":"General","default":false,"desc":"This pointer may alias with other pointers in the same function","metatype":"bool"},"_meta_offset":{"category":"General","default":[],"desc":"Initial offset to translate all indices by.","metatype":"list"},"_meta_shape":{"category":"General","default":[],"desc":"","metatype":"tuple"},"_meta_storage":{"category":"General","default":"Default","desc":"Storage location","metatype":"StorageType"},"_meta_strides":{"category":"General","default":[],"desc":"For each dimension, the number of elements to skip in order to obtain the next element in that dimension.","metatype":"tuple"},"_meta_total_size":{"category":"General","default":1,"desc":"The total allocated size of the array. Can be used for padding.","metatype":"SymbolicProperty"},"_meta_transient":{"category":"General","default":false,"desc":"","metatype":"bool"},"alignment":0,"allow_conflicts":false,"debuginfo":null,"dtype":"float64","lifetime":"Scope","location":{"gpu":"1"},"may_alias":false,"offset":["0"],"shape":["ceiling(N/2)"],"storage":"GPU_Global","strides":["1"],"total_size":"N","transient":true},"type":"Array"},"nested_slice_X_8_gpu_Y":{"attributes":{"_meta_alignment":{"category":"General","default":0,"desc":"Allocation alignment in bytes (0 uses compiler-default)","metatype":"int"},"_meta_allow_conflicts":{"category":"General","default":false,"desc":"If enabled, allows more than one memlet to write to the same memory location without conflict resolution.","metatype":"bool"},"_meta_debuginfo":{"category":"General","default":{"end_column":0,"end_line":0,"filename":null,"start_column":0,"start_line":0,"type":"DebugInfo"},"desc":"","metatype":"DebugInfo"},"_meta_dtype":{"category":"General","default":"int32","desc":"","metatype":"typeclass"},"_meta_lifetime":{"category":"General","default":"Scope","desc":"Data allocation span","metatype":"AllocationLifetime"},"_meta_location":{"category":"General","default":{},"desc":"Full storage location identifier (e.g., rank, GPU ID)","metatype":"dict"},"_meta_may_alias":{"category":"General","default":false,"desc":"This pointer may alias with other pointers in the same function","metatype":"bool"},"_meta_offset":{"category":"General","default":[],"desc":"Initial offset to translate all indices by.","metatype":"list"},"_meta_shape":{"category":"General","default":[],"desc":"","metatype":"tuple"},"_meta_storage":{"category":"General","default":"Default","desc":"Storage location","metatype":"StorageType"},"_meta_strides":{"category":"General","default":[],"desc":"For each dimension, the number of elements to skip in order to obtain the next element in that dimension.","metatype":"tuple"},"_meta_total_size":{"category":"General","default":1,"desc":"The total allocated size of the array. Can be used for padding.","metatype":"SymbolicProperty"},"_meta_transient":{"category":"General","default":false,"desc":"","metatype":"bool"},"alignment":0,"allow_conflicts":false,"debuginfo":null,"dtype":"float64","lifetime":"Scope","location":{"gpu":"0"},"may_alias":false,"offset":["0"],"shape":["ceiling(N/2)"],"storage":"GPU_Global","strides":["1"],"total_size":"N","transient":true},"type":"Array"},"nested_slice_X_8_gpu_Y_0":{"attributes":{"_meta_alignment":{"category":"General","default":0,"desc":"Allocation alignment in bytes (0 uses compiler-default)","metatype":"int"},"_meta_allow_conflicts":{"category":"General","default":false,"desc":"If enabled, allows more than one memlet to write to the same memory location without conflict resolution.","metatype":"bool"},"_meta_debuginfo":{"category":"General","default":{"end_column":0,"end_line":0,"filename":null,"start_column":0,"start_line":0,"type":"DebugInfo"},"desc":"","metatype":"DebugInfo"},"_meta_dtype":{"category":"General","default":"int32","desc":"","metatype":"typeclass"},"_meta_lifetime":{"category":"General","default":"Scope","desc":"Data allocation span","metatype":"AllocationLifetime"},"_meta_location":{"category":"General","default":{},"desc":"Full storage location identifier (e.g., rank, GPU ID)","metatype":"dict"},"_meta_may_alias":{"category":"General","default":false,"desc":"This pointer may alias with other pointers in the same function","metatype":"bool"},"_meta_offset":{"category":"General","default":[],"desc":"Initial offset to translate all indices by.","metatype":"list"},"_meta_shape":{"category":"General","default":[],"desc":"","metatype":"tuple"},"_meta_storage":{"category":"General","default":"Default","desc":"Storage location","metatype":"StorageType"},"_meta_strides":{"category":"General","default":[],"desc":"For each dimension, the number of elements to skip in order to obtain the next element in that dimension.","metatype":"tuple"},"_meta_total_size":{"category":"General","default":1,"desc":"The total allocated size of the array. Can be used for padding.","metatype":"SymbolicProperty"},"_meta_transient":{"category":"General","default":false,"desc":"","metatype":"bool"},"alignment":0,"allow_conflicts":false,"debuginfo":null,"dtype":"float64","lifetime":"Scope","location":{"gpu":"1"},"may_alias":false,"offset":["0"],"shape":["ceiling(N/2)"],"storage":"GPU_Global","strides":["1"],"total_size":"N","transient":true},"type":"Array"}},"_meta__arrays":{"category":"General","default":{},"desc":"Data descriptors for this SDFG","metatype":"dict"},"_meta_arg_types":{"category":"General","default":[],"desc":"Formal parameter list","metatype":"OrderedDictProperty"},"_meta_constants_prop":{"category":"General","default":{},"desc":"Compile-time constants","metatype":"dict"},"_meta_exit_code":{"category":"General","default":{},"desc":"Code generated in the `__dace_exit` function.","metatype":"dict"},"_meta_global_code":{"category":"General","default":{},"desc":"Code generated in a global scope on the output files.","metatype":"dict"},"_meta_init_code":{"category":"General","default":{},"desc":"Code generated in the `__dace_init` function.","metatype":"dict"},"_meta_orig_sdfg":{"category":"General","default":null,"desc":"","metatype":"SDFGReferenceProperty"},"_meta_symbols":{"category":"General","default":{},"desc":"Global symbols for this SDFG","metatype":"dict"},"_meta_transformation_hist":{"category":"General","default":[],"desc":"","metatype":"list"},"arg_types":[],"constants_prop":{},"exit_code":{"frame":{"language":"CPP","string_data":""}},"global_code":{"frame":{"language":"CPP","string_data":""}},"init_code":{"frame":{"language":"CPP","string_data":""}},"name":"axpy","orig_sdfg":"{\"attributes\":{\"_arrays\":{\"A\":{\"attributes\":{\"_meta_allow_conflicts\":{\"category\":\"General\",\"default\":false,\"desc\":\"\",\"metatype\":\"bool\"},\"_meta_debuginfo\":{\"category\":\"General\",\"default\":{\"end_column\":0,\"end_line\":0,\"filename\":null,\"start_column\":0,\"start_line\":0,\"type\":\"DebugInfo\"},\"desc\":\"\",\"metatype\":\"DebugInfo\"},\"_meta_dtype\":{\"category\":\"General\",\"default\":\"int32\",\"desc\":\"\",\"metatype\":\"typeclass\"},\"_meta_lifetime\":{\"category\":\"General\",\"default\":\"Scope\",\"desc\":\"Data allocation span\",\"metatype\":\"AllocationLifetime\"},\"_meta_location\":{\"category\":\"General\",\"default\":{},\"desc\":\"Full storage location identifier (e.g., rank, GPU ID)\",\"metatype\":\"dict\"},\"_meta_shape\":{\"category\":\"General\",\"default\":[],\"desc\":\"\",\"metatype\":\"tuple\"},\"_meta_storage\":{\"category\":\"General\",\"default\":\"Default\",\"desc\":\"Storage location\",\"metatype\":\"StorageType\"},\"_meta_transient\":{\"category\":\"General\",\"default\":false,\"desc\":\"\",\"metatype\":\"bool\"},\"allow_conflicts\":false,\"debuginfo\":null,\"dtype\":\"float64\",\"lifetime\":\"Scope\",\"location\":{},\"shape\":[\"1\"],\"storage\":\"Default\",\"transient\":false},\"type\":\"Scalar\"},\"X\":{\"attributes\":{\"_meta_alignment\":{\"category\":\"General\",\"default\":0,\"desc\":\"Allocation alignment in bytes (0 uses compiler-default)\",\"metatype\":\"int\"},\"_meta_allow_conflicts\":{\"category\":\"General\",\"default\":false,\"desc\":\"If enabled, allows more than one memlet to write to the same memory location without conflict resolution.\",\"metatype\":\"bool\"},\"_meta_debuginfo\":{\"category\":\"General\",\"default\":{\"end_column\":0,\"end_line\":0,\"filename\":null,\"start_column\":0,\"start_line\":0,\"type\":\"DebugInfo\"},\"desc\":\"\",\"metatype\":\"DebugInfo\"},\"_meta_dtype\":{\"category\":\"General\",\"default\":\"int32\",\"desc\":\"\",\"metatype\":\"typeclass\"},\"_meta_lifetime\":{\"category\":\"General\",\"default\":\"Scope\",\"desc\":\"Data allocation span\",\"metatype\":\"AllocationLifetime\"},\"_meta_location\":{\"category\":\"General\",\"default\":{},\"desc\":\"Full storage location identifier (e.g., rank, GPU ID)\",\"metatype\":\"dict\"},\"_meta_may_alias\":{\"category\":\"General\",\"default\":false,\"desc\":\"This pointer may alias with other pointers in the same function\",\"metatype\":\"bool\"},\"_meta_offset\":{\"category\":\"General\",\"default\":[],\"desc\":\"Initial offset to translate all indices by.\",\"metatype\":\"list\"},\"_meta_shape\":{\"category\":\"General\",\"default\":[],\"desc\":\"\",\"metatype\":\"tuple\"},\"_meta_storage\":{\"category\":\"General\",\"default\":\"Default\",\"desc\":\"Storage location\",\"metatype\":\"StorageType\"},\"_meta_strides\":{\"category\":\"General\",\"default\":[],\"desc\":\"For each dimension, the number of elements to skip in order to obtain the next element in that dimension.\",\"metatype\":\"tuple\"},\"_meta_total_size\":{\"category\":\"General\",\"default\":1,\"desc\":\"The total allocated size of the array. Can be used for padding.\",\"metatype\":\"SymbolicProperty\"},\"_meta_transient\":{\"category\":\"General\",\"default\":false,\"desc\":\"\",\"metatype\":\"bool\"},\"alignment\":0,\"allow_conflicts\":false,\"debuginfo\":null,\"dtype\":\"float64\",\"lifetime\":\"Scope\",\"location\":{},\"may_alias\":false,\"offset\":[\"0\"],\"shape\":[\"N\"],\"storage\":\"Default\",\"strides\":[\"1\"],\"total_size\":\"N\",\"transient\":false},\"type\":\"Array\"},\"X1\":{\"attributes\":{\"_meta_alignment\":{\"category\":\"General\",\"default\":0,\"desc\":\"Allocation alignment in bytes (0 uses compiler-default)\",\"metatype\":\"int\"},\"_meta_allow_conflicts\":{\"category\":\"General\",\"default\":false,\"desc\":\"If enabled, allows more than one memlet to write to the same memory location without conflict resolution.\",\"metatype\":\"bool\"},\"_meta_debuginfo\":{\"category\":\"General\",\"default\":{\"end_column\":0,\"end_line\":0,\"filename\":null,\"start_column\":0,\"start_line\":0,\"type\":\"DebugInfo\"},\"desc\":\"\",\"metatype\":\"DebugInfo\"},\"_meta_dtype\":{\"category\":\"General\",\"default\":\"int32\",\"desc\":\"\",\"metatype\":\"typeclass\"},\"_meta_lifetime\":{\"category\":\"General\",\"default\":\"Scope\",\"desc\":\"Data allocation span\",\"metatype\":\"AllocationLifetime\"},\"_meta_location\":{\"category\":\"General\",\"default\":{},\"desc\":\"Full storage location identifier (e.g., rank, GPU ID)\",\"metatype\":\"dict\"},\"_meta_may_alias\":{\"category\":\"General\",\"default\":false,\"desc\":\"This pointer may alias with other pointers in the same function\",\"metatype\":\"bool\"},\"_meta_offset\":{\"category\":\"General\",\"default\":[],\"desc\":\"Initial offset to translate all indices by.\",\"metatype\":\"list\"},\"_meta_shape\":{\"category\":\"General\",\"default\":[],\"desc\":\"\",\"metatype\":\"tuple\"},\"_meta_storage\":{\"category\":\"General\",\"default\":\"Default\",\"desc\":\"Storage location\",\"metatype\":\"StorageType\"},\"_meta_strides\":{\"category\":\"General\",\"default\":[],\"desc\":\"For each dimension, the number of elements to skip in order to obtain the next element in that dimension.\",\"metatype\":\"tuple\"},\"_meta_total_size\":{\"category\":\"General\",\"default\":1,\"desc\":\"The total allocated size of the array. Can be used for padding.\",\"metatype\":\"SymbolicProperty\"},\"_meta_transient\":{\"category\":\"General\",\"default\":false,\"desc\":\"\",\"metatype\":\"bool\"},\"alignment\":0,\"allow_conflicts\":false,\"debuginfo\":null,\"dtype\":\"float64\",\"lifetime\":\"Scope\",\"location\":{},\"may_alias\":false,\"offset\":[\"0\"],\"shape\":[\"ceiling(N/2)\"],\"storage\":\"Default\",\"strides\":[\"1\"],\"total_size\":\"ceiling(N/2)\",\"transient\":true},\"type\":\"Array\"},\"X2\":{\"attributes\":{\"_meta_alignment\":{\"category\":\"General\",\"default\":0,\"desc\":\"Allocation alignment in bytes (0 uses compiler-default)\",\"metatype\":\"int\"},\"_meta_allow_conflicts\":{\"category\":\"General\",\"default\":false,\"desc\":\"If enabled, allows more than one memlet to write to the same memory location without conflict resolution.\",\"metatype\":\"bool\"},\"_meta_debuginfo\":{\"category\":\"General\",\"default\":{\"end_column\":0,\"end_line\":0,\"filename\":null,\"start_column\":0,\"start_line\":0,\"type\":\"DebugInfo\"},\"desc\":\"\",\"metatype\":\"DebugInfo\"},\"_meta_dtype\":{\"category\":\"General\",\"default\":\"int32\",\"desc\":\"\",\"metatype\":\"typeclass\"},\"_meta_lifetime\":{\"category\":\"General\",\"default\":\"Scope\",\"desc\":\"Data allocation span\",\"metatype\":\"AllocationLifetime\"},\"_meta_location\":{\"category\":\"General\",\"default\":{},\"desc\":\"Full storage location identifier (e.g., rank, GPU ID)\",\"metatype\":\"dict\"},\"_meta_may_alias\":{\"category\":\"General\",\"default\":false,\"desc\":\"This pointer may alias with other pointers in the same function\",\"metatype\":\"bool\"},\"_meta_offset\":{\"category\":\"General\",\"default\":[],\"desc\":\"Initial offset to translate all indices by.\",\"metatype\":\"list\"},\"_meta_shape\":{\"category\":\"General\",\"default\":[],\"desc\":\"\",\"metatype\":\"tuple\"},\"_meta_storage\":{\"category\":\"General\",\"default\":\"Default\",\"desc\":\"Storage location\",\"metatype\":\"StorageType\"},\"_meta_strides\":{\"category\":\"General\",\"default\":[],\"desc\":\"For each dimension, the number of elements to skip in order to obtain the next element in that dimension.\",\"metatype\":\"tuple\"},\"_meta_total_size\":{\"category\":\"General\",\"default\":1,\"desc\":\"The total allocated size of the array. Can be used for padding.\",\"metatype\":\"SymbolicProperty\"},\"_meta_transient\":{\"category\":\"General\",\"default\":false,\"desc\":\"\",\"metatype\":\"bool\"},\"alignment\":0,\"allow_conflicts\":false,\"debuginfo\":null,\"dtype\":\"float64\",\"lifetime\":\"Scope\",\"location\":{},\"may_alias\":false,\"offset\":[\"0\"],\"shape\":[\"ceiling(N/2)\"],\"storage\":\"Default\",\"strides\":[\"1\"],\"total_size\":\"ceiling(N/2)\",\"transient\":true},\"type\":\"Array\"},\"Y\":{\"attributes\":{\"_meta_alignment\":{\"category\":\"General\",\"default\":0,\"desc\":\"Allocation alignment in bytes (0 uses compiler-default)\",\"metatype\":\"int\"},\"_meta_allow_conflicts\":{\"category\":\"General\",\"default\":false,\"desc\":\"If enabled, allows more than one memlet to write to the same memory location without conflict resolution.\",\"metatype\":\"bool\"},\"_meta_debuginfo\":{\"category\":\"General\",\"default\":{\"end_column\":0,\"end_line\":0,\"filename\":null,\"start_column\":0,\"start_line\":0,\"type\":\"DebugInfo\"},\"desc\":\"\",\"metatype\":\"DebugInfo\"},\"_meta_dtype\":{\"category\":\"General\",\"default\":\"int32\",\"desc\":\"\",\"metatype\":\"typeclass\"},\"_meta_lifetime\":{\"category\":\"General\",\"default\":\"Scope\",\"desc\":\"Data allocation span\",\"metatype\":\"AllocationLifetime\"},\"_meta_location\":{\"category\":\"General\",\"default\":{},\"desc\":\"Full storage location identifier (e.g., rank, GPU ID)\",\"metatype\":\"dict\"},\"_meta_may_alias\":{\"category\":\"General\",\"default\":false,\"desc\":\"This pointer may alias with other pointers in the same function\",\"metatype\":\"bool\"},\"_meta_offset\":{\"category\":\"General\",\"default\":[],\"desc\":\"Initial offset to translate all indices by.\",\"metatype\":\"list\"},\"_meta_shape\":{\"category\":\"General\",\"default\":[],\"desc\":\"\",\"metatype\":\"tuple\"},\"_meta_storage\":{\"category\":\"General\",\"default\":\"Default\",\"desc\":\"Storage location\",\"metatype\":\"StorageType\"},\"_meta_strides\":{\"category\":\"General\",\"default\":[],\"desc\":\"For each dimension, the number of elements to skip in order to obtain the next element in that dimension.\",\"metatype\":\"tuple\"},\"_meta_total_size\":{\"category\":\"General\",\"default\":1,\"desc\":\"The total allocated size of the array. Can be used for padding.\",\"metatype\":\"SymbolicProperty\"},\"_meta_transient\":{\"category\":\"General\",\"default\":false,\"desc\":\"\",\"metatype\":\"bool\"},\"alignment\":0,\"allow_conflicts\":false,\"debuginfo\":null,\"dtype\":\"float64\",\"lifetime\":\"Scope\",\"location\":{},\"may_alias\":false,\"offset\":[\"0\"],\"shape\":[\"N\"],\"storage\":\"Default\",\"strides\":[\"1\"],\"total_size\":\"N\",\"transient\":false},\"type\":\"Array\"},\"Y1\":{\"attributes\":{\"_meta_alignment\":{\"category\":\"General\",\"default\":0,\"desc\":\"Allocation alignment in bytes (0 uses compiler-default)\",\"metatype\":\"int\"},\"_meta_allow_conflicts\":{\"category\":\"General\",\"default\":false,\"desc\":\"If enabled, allows more than one memlet to write to the same memory location without conflict resolution.\",\"metatype\":\"bool\"},\"_meta_debuginfo\":{\"category\":\"General\",\"default\":{\"end_column\":0,\"end_line\":0,\"filename\":null,\"start_column\":0,\"start_line\":0,\"type\":\"DebugInfo\"},\"desc\":\"\",\"metatype\":\"DebugInfo\"},\"_meta_dtype\":{\"category\":\"General\",\"default\":\"int32\",\"desc\":\"\",\"metatype\":\"typeclass\"},\"_meta_lifetime\":{\"category\":\"General\",\"default\":\"Scope\",\"desc\":\"Data allocation span\",\"metatype\":\"AllocationLifetime\"},\"_meta_location\":{\"category\":\"General\",\"default\":{},\"desc\":\"Full storage location identifier (e.g., rank, GPU ID)\",\"metatype\":\"dict\"},\"_meta_may_alias\":{\"category\":\"General\",\"default\":false,\"desc\":\"This pointer may alias with other pointers in the same function\",\"metatype\":\"bool\"},\"_meta_offset\":{\"category\":\"General\",\"default\":[],\"desc\":\"Initial offset to translate all indices by.\",\"metatype\":\"list\"},\"_meta_shape\":{\"category\":\"General\",\"default\":[],\"desc\":\"\",\"metatype\":\"tuple\"},\"_meta_storage\":{\"category\":\"General\",\"default\":\"Default\",\"desc\":\"Storage location\",\"metatype\":\"StorageType\"},\"_meta_strides\":{\"category\":\"General\",\"default\":[],\"desc\":\"For each dimension, the number of elements to skip in order to obtain the next element in that dimension.\",\"metatype\":\"tuple\"},\"_meta_total_size\":{\"category\":\"General\",\"default\":1,\"desc\":\"The total allocated size of the array. Can be used for padding.\",\"metatype\":\"SymbolicProperty\"},\"_meta_transient\":{\"category\":\"General\",\"default\":false,\"desc\":\"\",\"metatype\":\"bool\"},\"alignment\":0,\"allow_conflicts\":false,\"debuginfo\":null,\"dtype\":\"float64\",\"lifetime\":\"Scope\",\"location\":{},\"may_alias\":false,\"offset\":[\"0\"],\"shape\":[\"ceiling(N/2)\"],\"storage\":\"Default\",\"strides\":[\"1\"],\"total_size\":\"ceiling(N/2)\",\"transient\":true},\"type\":\"Array\"},\"Y2\":{\"attributes\":{\"_meta_alignment\":{\"category\":\"General\",\"default\":0,\"desc\":\"Allocation alignment in bytes (0 uses compiler-default)\",\"metatype\":\"int\"},\"_meta_allow_conflicts\":{\"category\":\"General\",\"default\":false,\"desc\":\"If enabled, allows more than one memlet to write to the same memory location without conflict resolution.\",\"metatype\":\"bool\"},\"_meta_debuginfo\":{\"category\":\"General\",\"default\":{\"end_column\":0,\"end_line\":0,\"filename\":null,\"start_column\":0,\"start_line\":0,\"type\":\"DebugInfo\"},\"desc\":\"\",\"metatype\":\"DebugInfo\"},\"_meta_dtype\":{\"category\":\"General\",\"default\":\"int32\",\"desc\":\"\",\"metatype\":\"typeclass\"},\"_meta_lifetime\":{\"category\":\"General\",\"default\":\"Scope\",\"desc\":\"Data allocation span\",\"metatype\":\"AllocationLifetime\"},\"_meta_location\":{\"category\":\"General\",\"default\":{},\"desc\":\"Full storage location identifier (e.g., rank, GPU ID)\",\"metatype\":\"dict\"},\"_meta_may_alias\":{\"category\":\"General\",\"default\":false,\"desc\":\"This pointer may alias with other pointers in the same function\",\"metatype\":\"bool\"},\"_meta_offset\":{\"category\":\"General\",\"default\":[],\"desc\":\"Initial offset to translate all indices by.\",\"metatype\":\"list\"},\"_meta_shape\":{\"category\":\"General\",\"default\":[],\"desc\":\"\",\"metatype\":\"tuple\"},\"_meta_storage\":{\"category\":\"General\",\"default\":\"Default\",\"desc\":\"Storage location\",\"metatype\":\"StorageType\"},\"_meta_strides\":{\"category\":\"General\",\"default\":[],\"desc\":\"For each dimension, the number of elements to skip in order to obtain the next element in that dimension.\",\"metatype\":\"tuple\"},\"_meta_total_size\":{\"category\":\"General\",\"default\":1,\"desc\":\"The total allocated size of the array. Can be used for padding.\",\"metatype\":\"SymbolicProperty\"},\"_meta_transient\":{\"category\":\"General\",\"default\":false,\"desc\":\"\",\"metatype\":\"bool\"},\"alignment\":0,\"allow_conflicts\":false,\"debuginfo\":null,\"dtype\":\"float64\",\"lifetime\":\"Scope\",\"location\":{},\"may_alias\":false,\"offset\":[\"0\"],\"shape\":[\"ceiling(N/2)\"],\"storage\":\"Default\",\"strides\":[\"1\"],\"total_size\":\"ceiling(N/2)\",\"transient\":true},\"type\":\"Array\"}},\"_meta__arrays\":{\"category\":\"General\",\"default\":{},\"desc\":\"Data descriptors for this SDFG\",\"metatype\":\"dict\"},\"_meta_arg_types\":{\"category\":\"General\",\"default\":[],\"desc\":\"Formal parameter list\",\"metatype\":\"OrderedDictProperty\"},\"_meta_constants_prop\":{\"category\":\"General\",\"default\":{},\"desc\":\"Compile-time constants\",\"metatype\":\"dict\"},\"_meta_exit_code\":{\"category\":\"General\",\"default\":{},\"desc\":\"Code generated in the `__dace_exit` function.\",\"metatype\":\"dict\"},\"_meta_global_code\":{\"category\":\"General\",\"default\":{},\"desc\":\"Code generated in a global scope on the output files.\",\"metatype\":\"dict\"},\"_meta_init_code\":{\"category\":\"General\",\"default\":{},\"desc\":\"Code generated in the `__dace_init` function.\",\"metatype\":\"dict\"},\"_meta_orig_sdfg\":{\"category\":\"General\",\"default\":null,\"desc\":\"\",\"metatype\":\"SDFGReferenceProperty\"},\"_meta_symbols\":{\"category\":\"General\",\"default\":{},\"desc\":\"Global symbols for this SDFG\",\"metatype\":\"dict\"},\"_meta_transformation_hist\":{\"category\":\"General\",\"default\":[],\"desc\":\"\",\"metatype\":\"list\"},\"arg_types\":[],\"constants_prop\":{},\"exit_code\":{\"frame\":{\"language\":\"CPP\",\"string_data\":\"\"}},\"global_code\":{\"frame\":{\"language\":\"CPP\",\"string_data\":\"\"}},\"init_code\":{\"frame\":{\"language\":\"CPP\",\"string_data\":\"\"}},\"name\":\"axpy\",\"orig_sdfg\":null,\"symbols\":{\"N\":\"int32\"},\"transformation_hist\":[]},\"edges\":[],\"nodes\":[{\"attributes\":{\"_meta_dynamic_executions\":{\"category\":\"General\",\"default\":true,\"desc\":\"The number of executions of this state is dynamic\",\"metatype\":\"bool\"},\"_meta_executions\":{\"category\":\"General\",\"default\":0,\"desc\":\"The number of times this state gets executed (0 stands for unbounded)\",\"metatype\":\"SymbolicProperty\"},\"_meta_instrument\":{\"category\":\"General\",\"default\":\"No_Instrumentation\",\"desc\":\"Measure execution statistics with given method\",\"metatype\":\"InstrumentationType\"},\"_meta_is_collapsed\":{\"category\":\"General\",\"default\":false,\"desc\":\"Show this node/scope/state as collapsed\",\"metatype\":\"bool\"},\"_meta_location\":{\"category\":\"General\",\"default\":{},\"desc\":\"Full storage location identifier (e.g., rank, GPU ID)\",\"metatype\":\"dict\"},\"_meta_nosync\":{\"category\":\"General\",\"default\":false,\"desc\":\"Do not synchronize at the end of the state\",\"metatype\":\"bool\"},\"_meta_ranges\":{\"category\":\"General\",\"default\":{},\"desc\":\"Variable ranges, typically within loops\",\"metatype\":\"dict\"},\"dynamic_executions\":true,\"executions\":\"0\",\"instrument\":\"No_Instrumentation\",\"is_collapsed\":false,\"location\":{},\"nosync\":false,\"ranges\":{}},\"collapsed\":false,\"edges\":[{\"attributes\":{\"data\":{\"attributes\":{\"_meta_allow_oob\":{\"category\":\"General\",\"default\":false,\"desc\":\"Bypass out-of-bounds validation\",\"metatype\":\"bool\"},\"_meta_data\":{\"category\":\"General\",\"default\":null,\"desc\":\"Data descriptor attached to this memlet\",\"metatype\":\"DataProperty\"},\"_meta_debuginfo\":{\"category\":\"General\",\"default\":{\"end_column\":0,\"end_line\":0,\"filename\":null,\"start_column\":0,\"start_line\":0,\"type\":\"DebugInfo\"},\"desc\":\"Line information to track source and generated code\",\"metatype\":\"DebugInfo\"},\"_meta_dynamic\":{\"category\":\"General\",\"default\":false,\"desc\":\"Is the number of elements moved determined at runtime (e.g., data dependent)\",\"metatype\":\"Property\"},\"_meta_other_subset\":{\"category\":\"General\",\"default\":null,\"desc\":\"Subset of elements after reindexing to the data not attached to this edge (e.g., for offsets and reshaping).\",\"metatype\":\"SubsetProperty\"},\"_meta_subset\":{\"category\":\"General\",\"default\":null,\"desc\":\"Subset of elements to move from the data attached to this edge.\",\"metatype\":\"SubsetProperty\"},\"_meta_volume\":{\"category\":\"General\",\"default\":0,\"desc\":\"The exact number of elements moved using this memlet, or the maximum number if dynamic=True (with 0 as unbounded)\",\"metatype\":\"SymbolicProperty\"},\"_meta_wcr\":{\"category\":\"General\",\"default\":null,\"desc\":\"If set, defines a write-conflict resolution lambda function. The syntax of the lambda function receives two elements: `current` value and `new` value, and returns the value after resolution\",\"metatype\":\"LambdaProperty\"},\"_meta_wcr_nonatomic\":{\"category\":\"General\",\"default\":false,\"desc\":\"If True, always generates non-conflicting (non-atomic) writes in resulting code\",\"metatype\":\"bool\"},\"allow_oob\":false,\"data\":\"A\",\"debuginfo\":null,\"dst_subset\":null,\"dynamic\":false,\"num_accesses\":\"ceiling(N/2)\",\"other_subset\":null,\"src_subset\":{\"ranges\":[{\"end\":\"0\",\"start\":\"0\",\"step\":\"1\",\"tile\":\"1\"}],\"type\":\"Range\"},\"subset\":{\"ranges\":[{\"end\":\"0\",\"start\":\"0\",\"step\":\"1\",\"tile\":\"1\"}],\"type\":\"Range\"},\"volume\":\"ceiling(N/2)\",\"wcr\":null,\"wcr_nonatomic\":false},\"type\":\"Memlet\"}},\"dst\":\"2\",\"dst_connector\":\"IN_A\",\"src\":\"4\",\"src_connector\":null,\"type\":\"MultiConnectorEdge\"},{\"attributes\":{\"data\":{\"attributes\":{\"_meta_allow_oob\":{\"category\":\"General\",\"default\":false,\"desc\":\"Bypass out-of-bounds validation\",\"metatype\":\"bool\"},\"_meta_data\":{\"category\":\"General\",\"default\":null,\"desc\":\"Data descriptor attached to this memlet\",\"metatype\":\"DataProperty\"},\"_meta_debuginfo\":{\"category\":\"General\",\"default\":{\"end_column\":0,\"end_line\":0,\"filename\":null,\"start_column\":0,\"start_line\":0,\"type\":\"DebugInfo\"},\"desc\":\"Line information to track source and generated code\",\"metatype\":\"DebugInfo\"},\"_meta_dynamic\":{\"category\":\"General\",\"default\":false,\"desc\":\"Is the number of elements moved determined at runtime (e.g., data dependent)\",\"metatype\":\"Property\"},\"_meta_other_subset\":{\"category\":\"General\",\"default\":null,\"desc\":\"Subset of elements after reindexing to the data not attached to this edge (e.g., for offsets and reshaping).\",\"metatype\":\"SubsetProperty\"},\"_meta_subset\":{\"category\":\"General\",\"default\":null,\"desc\":\"Subset of elements to move from the data attached to this edge.\",\"metatype\":\"SubsetProperty\"},\"_meta_volume\":{\"category\":\"General\",\"default\":0,\"desc\":\"The exact number of elements moved using this memlet, or the maximum number if dynamic=True (with 0 as unbounded)\",\"metatype\":\"SymbolicProperty\"},\"_meta_wcr\":{\"category\":\"General\",\"default\":null,\"desc\":\"If set, defines a write-conflict resolution lambda function. The syntax of the lambda function receives two elements: `current` value and `new` value, and returns the value after resolution\",\"metatype\":\"LambdaProperty\"},\"_meta_wcr_nonatomic\":{\"category\":\"General\",\"default\":false,\"desc\":\"If True, always generates non-conflicting (non-atomic) writes in resulting code\",\"metatype\":\"bool\"},\"allow_oob\":false,\"data\":\"A\",\"debuginfo\":null,\"dst_subset\":null,\"dynamic\":false,\"num_accesses\":\"ceiling(N/2)\",\"other_subset\":null,\"src_subset\":{\"ranges\":[{\"end\":\"0\",\"start\":\"0\",\"step\":\"1\",\"tile\":\"1\"}],\"type\":\"Range\"},\"subset\":{\"ranges\":[{\"end\":\"0\",\"start\":\"0\",\"step\":\"1\",\"tile\":\"1\"}],\"type\":\"Range\"},\"volume\":\"ceiling(N/2)\",\"wcr\":null,\"wcr_nonatomic\":false},\"type\":\"Memlet\"}},\"dst\":\"6\",\"dst_connector\":\"IN_A\",\"src\":\"4\",\"src_connector\":null,\"type\":\"MultiConnectorEdge\"},{\"attributes\":{\"data\":{\"attributes\":{\"_meta_allow_oob\":{\"category\":\"General\",\"default\":false,\"desc\":\"Bypass out-of-bounds validation\",\"metatype\":\"bool\"},\"_meta_data\":{\"category\":\"General\",\"default\":null,\"desc\":\"Data descriptor attached to this memlet\",\"metatype\":\"DataProperty\"},\"_meta_debuginfo\":{\"category\":\"General\",\"default\":{\"end_column\":0,\"end_line\":0,\"filename\":null,\"start_column\":0,\"start_line\":0,\"type\":\"DebugInfo\"},\"desc\":\"Line information to track source and generated code\",\"metatype\":\"DebugInfo\"},\"_meta_dynamic\":{\"category\":\"General\",\"default\":false,\"desc\":\"Is the number of elements moved determined at runtime (e.g., data dependent)\",\"metatype\":\"Property\"},\"_meta_other_subset\":{\"category\":\"General\",\"default\":null,\"desc\":\"Subset of elements after reindexing to the data not attached to this edge (e.g., for offsets and reshaping).\",\"metatype\":\"SubsetProperty\"},\"_meta_subset\":{\"category\":\"General\",\"default\":null,\"desc\":\"Subset of elements to move from the data attached to this edge.\",\"metatype\":\"SubsetProperty\"},\"_meta_volume\":{\"category\":\"General\",\"default\":0,\"desc\":\"The exact number of elements moved using this memlet, or the maximum number if dynamic=True (with 0 as unbounded)\",\"metatype\":\"SymbolicProperty\"},\"_meta_wcr\":{\"category\":\"General\",\"default\":null,\"desc\":\"If set, defines a write-conflict resolution lambda function. The syntax of the lambda function receives two elements: `current` value and `new` value, and returns the value after resolution\",\"metatype\":\"LambdaProperty\"},\"_meta_wcr_nonatomic\":{\"category\":\"General\",\"default\":false,\"desc\":\"If True, always generates non-conflicting (non-atomic) writes in resulting code\",\"metatype\":\"bool\"},\"allow_oob\":false,\"data\":\"X\",\"debuginfo\":null,\"dst_subset\":null,\"dynamic\":false,\"num_accesses\":\"ceiling(N/2)\",\"other_subset\":null,\"src_subset\":{\"ranges\":[{\"end\":\"N/2 - 1\",\"start\":\"0\",\"step\":\"1\",\"tile\":\"1\"}],\"type\":\"Range\"},\"subset\":{\"ranges\":[{\"end\":\"N/2 - 1\",\"start\":\"0\",\"step\":\"1\",\"tile\":\"1\"}],\"type\":\"Range\"},\"volume\":\"ceiling(N/2)\",\"wcr\":null,\"wcr_nonatomic\":false},\"type\":\"Memlet\"}},\"dst\":\"2\",\"dst_connector\":\"IN___tmp0\",\"src\":\"0\",\"src_connector\":null,\"type\":\"MultiConnectorEdge\"},{\"attributes\":{\"data\":{\"attributes\":{\"_meta_allow_oob\":{\"category\":\"General\",\"default\":false,\"desc\":\"Bypass out-of-bounds validation\",\"metatype\":\"bool\"},\"_meta_data\":{\"category\":\"General\",\"default\":null,\"desc\":\"Data descriptor attached to this memlet\",\"metatype\":\"DataProperty\"},\"_meta_debuginfo\":{\"category\":\"General\",\"default\":{\"end_column\":0,\"end_line\":0,\"filename\":null,\"start_column\":0,\"start_line\":0,\"type\":\"DebugInfo\"},\"desc\":\"Line information to track source and generated code\",\"metatype\":\"DebugInfo\"},\"_meta_dynamic\":{\"category\":\"General\",\"default\":false,\"desc\":\"Is the number of elements moved determined at runtime (e.g., data dependent)\",\"metatype\":\"Property\"},\"_meta_other_subset\":{\"category\":\"General\",\"default\":null,\"desc\":\"Subset of elements after reindexing to the data not attached to this edge (e.g., for offsets and reshaping).\",\"metatype\":\"SubsetProperty\"},\"_meta_subset\":{\"category\":\"General\",\"default\":null,\"desc\":\"Subset of elements to move from the data attached to this edge.\",\"metatype\":\"SubsetProperty\"},\"_meta_volume\":{\"category\":\"General\",\"default\":0,\"desc\":\"The exact number of elements moved using this memlet, or the maximum number if dynamic=True (with 0 as unbounded)\",\"metatype\":\"SymbolicProperty\"},\"_meta_wcr\":{\"category\":\"General\",\"default\":null,\"desc\":\"If set, defines a write-conflict resolution lambda function. The syntax of the lambda function receives two elements: `current` value and `new` value, and returns the value after resolution\",\"metatype\":\"LambdaProperty\"},\"_meta_wcr_nonatomic\":{\"category\":\"General\",\"default\":false,\"desc\":\"If True, always generates non-conflicting (non-atomic) writes in resulting code\",\"metatype\":\"bool\"},\"allow_oob\":false,\"data\":\"Y\",\"debuginfo\":null,\"dst_subset\":null,\"dynamic\":false,\"num_accesses\":\"ceiling(N/2)\",\"other_subset\":null,\"src_subset\":{\"ranges\":[{\"end\":\"N/2 - 1\",\"start\":\"0\",\"step\":\"1\",\"tile\":\"1\"}],\"type\":\"Range\"},\"subset\":{\"ranges\":[{\"end\":\"N/2 - 1\",\"start\":\"0\",\"step\":\"1\",\"tile\":\"1\"}],\"type\":\"Range\"},\"volume\":\"ceiling(N/2)\",\"wcr\":null,\"wcr_nonatomic\":false},\"type\":\"Memlet\"}},\"dst\":\"2\",\"dst_connector\":\"IN___tmp1\",\"src\":\"1\",\"src_connector\":null,\"type\":\"MultiConnectorEdge\"},{\"attributes\":{\"data\":{\"attributes\":{\"_meta_allow_oob\":{\"category\":\"General\",\"default\":false,\"desc\":\"Bypass out-of-bounds validation\",\"metatype\":\"bool\"},\"_meta_data\":{\"category\":\"General\",\"default\":null,\"desc\":\"Data descriptor attached to this memlet\",\"metatype\":\"DataProperty\"},\"_meta_debuginfo\":{\"category\":\"General\",\"default\":{\"end_column\":0,\"end_line\":0,\"filename\":null,\"start_column\":0,\"start_line\":0,\"type\":\"DebugInfo\"},\"desc\":\"Line information to track source and generated code\",\"metatype\":\"DebugInfo\"},\"_meta_dynamic\":{\"category\":\"General\",\"default\":false,\"desc\":\"Is the number of elements moved determined at runtime (e.g., data dependent)\",\"metatype\":\"Property\"},\"_meta_other_subset\":{\"category\":\"General\",\"default\":null,\"desc\":\"Subset of elements after reindexing to the data not attached to this edge (e.g., for offsets and reshaping).\",\"metatype\":\"SubsetProperty\"},\"_meta_subset\":{\"category\":\"General\",\"default\":null,\"desc\":\"Subset of elements to move from the data attached to this edge.\",\"metatype\":\"SubsetProperty\"},\"_meta_volume\":{\"category\":\"General\",\"default\":0,\"desc\":\"The exact number of elements moved using this memlet, or the maximum number if dynamic=True (with 0 as unbounded)\",\"metatype\":\"SymbolicProperty\"},\"_meta_wcr\":{\"category\":\"General\",\"default\":null,\"desc\":\"If set, defines a write-conflict resolution lambda function. The syntax of the lambda function receives two elements: `current` value and `new` value, and returns the value after resolution\",\"metatype\":\"LambdaProperty\"},\"_meta_wcr_nonatomic\":{\"category\":\"General\",\"default\":false,\"desc\":\"If True, always generates non-conflicting (non-atomic) writes in resulting code\",\"metatype\":\"bool\"},\"allow_oob\":false,\"data\":\"X\",\"debuginfo\":null,\"dst_subset\":null,\"dynamic\":false,\"num_accesses\":\"ceiling(N/2)\",\"other_subset\":null,\"src_subset\":{\"ranges\":[{\"end\":\"N - 1\",\"start\":\"N/2\",\"step\":\"1\",\"tile\":\"1\"}],\"type\":\"Range\"},\"subset\":{\"ranges\":[{\"end\":\"N - 1\",\"start\":\"N/2\",\"step\":\"1\",\"tile\":\"1\"}],\"type\":\"Range\"},\"volume\":\"ceiling(N/2)\",\"wcr\":null,\"wcr_nonatomic\":false},\"type\":\"Memlet\"}},\"dst\":\"6\",\"dst_connector\":\"IN___tmp2\",\"src\":\"0\",\"src_connector\":null,\"type\":\"MultiConnectorEdge\"},{\"attributes\":{\"data\":{\"attributes\":{\"_meta_allow_oob\":{\"category\":\"General\",\"default\":false,\"desc\":\"Bypass out-of-bounds validation\",\"metatype\":\"bool\"},\"_meta_data\":{\"category\":\"General\",\"default\":null,\"desc\":\"Data descriptor attached to this memlet\",\"metatype\":\"DataProperty\"},\"_meta_debuginfo\":{\"category\":\"General\",\"default\":{\"end_column\":0,\"end_line\":0,\"filename\":null,\"start_column\":0,\"start_line\":0,\"type\":\"DebugInfo\"},\"desc\":\"Line information to track source and generated code\",\"metatype\":\"DebugInfo\"},\"_meta_dynamic\":{\"category\":\"General\",\"default\":false,\"desc\":\"Is the number of elements moved determined at runtime (e.g., data dependent)\",\"metatype\":\"Property\"},\"_meta_other_subset\":{\"category\":\"General\",\"default\":null,\"desc\":\"Subset of elements after reindexing to the data not attached to this edge (e.g., for offsets and reshaping).\",\"metatype\":\"SubsetProperty\"},\"_meta_subset\":{\"category\":\"General\",\"default\":null,\"desc\":\"Subset of elements to move from the data attached to this edge.\",\"metatype\":\"SubsetProperty\"},\"_meta_volume\":{\"category\":\"General\",\"default\":0,\"desc\":\"The exact number of elements moved using this memlet, or the maximum number if dynamic=True (with 0 as unbounded)\",\"metatype\":\"SymbolicProperty\"},\"_meta_wcr\":{\"category\":\"General\",\"default\":null,\"desc\":\"If set, defines a write-conflict resolution lambda function. The syntax of the lambda function receives two elements: `current` value and `new` value, and returns the value after resolution\",\"metatype\":\"LambdaProperty\"},\"_meta_wcr_nonatomic\":{\"category\":\"General\",\"default\":false,\"desc\":\"If True, always generates non-conflicting (non-atomic) writes in resulting code\",\"metatype\":\"bool\"},\"allow_oob\":false,\"data\":\"Y\",\"debuginfo\":null,\"dst_subset\":null,\"dynamic\":false,\"num_accesses\":\"ceiling(N/2)\",\"other_subset\":null,\"src_subset\":{\"ranges\":[{\"end\":\"N - 1\",\"start\":\"N/2\",\"step\":\"1\",\"tile\":\"1\"}],\"type\":\"Range\"},\"subset\":{\"ranges\":[{\"end\":\"N - 1\",\"start\":\"N/2\",\"step\":\"1\",\"tile\":\"1\"}],\"type\":\"Range\"},\"volume\":\"ceiling(N/2)\",\"wcr\":null,\"wcr_nonatomic\":false},\"type\":\"Memlet\"}},\"dst\":\"6\",\"dst_connector\":\"IN___tmp3\",\"src\":\"1\",\"src_connector\":null,\"type\":\"MultiConnectorEdge\"},{\"attributes\":{\"data\":{\"attributes\":{\"_meta_allow_oob\":{\"category\":\"General\",\"default\":false,\"desc\":\"Bypass out-of-bounds validation\",\"metatype\":\"bool\"},\"_meta_data\":{\"category\":\"General\",\"default\":null,\"desc\":\"Data descriptor attached to this memlet\",\"metatype\":\"DataProperty\"},\"_meta_debuginfo\":{\"category\":\"General\",\"default\":{\"end_column\":0,\"end_line\":0,\"filename\":null,\"start_column\":0,\"start_line\":0,\"type\":\"DebugInfo\"},\"desc\":\"Line information to track source and generated code\",\"metatype\":\"DebugInfo\"},\"_meta_dynamic\":{\"category\":\"General\",\"default\":false,\"desc\":\"Is the number of elements moved determined at runtime (e.g., data dependent)\",\"metatype\":\"Property\"},\"_meta_other_subset\":{\"category\":\"General\",\"default\":null,\"desc\":\"Subset of elements after reindexing to the data not attached to this edge (e.g., for offsets and reshaping).\",\"metatype\":\"SubsetProperty\"},\"_meta_subset\":{\"category\":\"General\",\"default\":null,\"desc\":\"Subset of elements to move from the data attached to this edge.\",\"metatype\":\"SubsetProperty\"},\"_meta_volume\":{\"category\":\"General\",\"default\":0,\"desc\":\"The exact number of elements moved using this memlet, or the maximum number if dynamic=True (with 0 as unbounded)\",\"metatype\":\"SymbolicProperty\"},\"_meta_wcr\":{\"category\":\"General\",\"default\":null,\"desc\":\"If set, defines a write-conflict resolution lambda function. The syntax of the lambda function receives two elements: `current` value and `new` value, and returns the value after resolution\",\"metatype\":\"LambdaProperty\"},\"_meta_wcr_nonatomic\":{\"category\":\"General\",\"default\":false,\"desc\":\"If True, always generates non-conflicting (non-atomic) writes in resulting code\",\"metatype\":\"bool\"},\"allow_oob\":false,\"data\":\"A\",\"debuginfo\":null,\"dst_subset\":null,\"dynamic\":false,\"num_accesses\":\"1\",\"other_subset\":null,\"src_subset\":{\"ranges\":[{\"end\":\"0\",\"start\":\"0\",\"step\":\"1\",\"tile\":\"1\"}],\"type\":\"Range\"},\"subset\":{\"ranges\":[{\"end\":\"0\",\"start\":\"0\",\"step\":\"1\",\"tile\":\"1\"}],\"type\":\"Range\"},\"volume\":\"1\",\"wcr\":null,\"wcr_nonatomic\":false},\"type\":\"Memlet\"}},\"dst\":\"8\",\"dst_connector\":\"in_A1\",\"src\":\"2\",\"src_connector\":\"OUT_A\",\"type\":\"MultiConnectorEdge\"},{\"attributes\":{\"data\":{\"attributes\":{\"_meta_allow_oob\":{\"category\":\"General\",\"default\":false,\"desc\":\"Bypass out-of-bounds validation\",\"metatype\":\"bool\"},\"_meta_data\":{\"category\":\"General\",\"default\":null,\"desc\":\"Data descriptor attached to this memlet\",\"metatype\":\"DataProperty\"},\"_meta_debuginfo\":{\"category\":\"General\",\"default\":{\"end_column\":0,\"end_line\":0,\"filename\":null,\"start_column\":0,\"start_line\":0,\"type\":\"DebugInfo\"},\"desc\":\"Line information to track source and generated code\",\"metatype\":\"DebugInfo\"},\"_meta_dynamic\":{\"category\":\"General\",\"default\":false,\"desc\":\"Is the number of elements moved determined at runtime (e.g., data dependent)\",\"metatype\":\"Property\"},\"_meta_other_subset\":{\"category\":\"General\",\"default\":null,\"desc\":\"Subset of elements after reindexing to the data not attached to this edge (e.g., for offsets and reshaping).\",\"metatype\":\"SubsetProperty\"},\"_meta_subset\":{\"category\":\"General\",\"default\":null,\"desc\":\"Subset of elements to move from the data attached to this edge.\",\"metatype\":\"SubsetProperty\"},\"_meta_volume\":{\"category\":\"General\",\"default\":0,\"desc\":\"The exact number of elements moved using this memlet, or the maximum number if dynamic=True (with 0 as unbounded)\",\"metatype\":\"SymbolicProperty\"},\"_meta_wcr\":{\"category\":\"General\",\"default\":null,\"desc\":\"If set, defines a write-conflict resolution lambda function. The syntax of the lambda function receives two elements: `current` value and `new` value, and returns the value after resolution\",\"metatype\":\"LambdaProperty\"},\"_meta_wcr_nonatomic\":{\"category\":\"General\",\"default\":false,\"desc\":\"If True, always generates non-conflicting (non-atomic) writes in resulting code\",\"metatype\":\"bool\"},\"allow_oob\":false,\"data\":\"A\",\"debuginfo\":null,\"dst_subset\":null,\"dynamic\":false,\"num_accesses\":\"1\",\"other_subset\":null,\"src_subset\":{\"ranges\":[{\"end\":\"0\",\"start\":\"0\",\"step\":\"1\",\"tile\":\"1\"}],\"type\":\"Range\"},\"subset\":{\"ranges\":[{\"end\":\"0\",\"start\":\"0\",\"step\":\"1\",\"tile\":\"1\"}],\"type\":\"Range\"},\"volume\":\"1\",\"wcr\":null,\"wcr_nonatomic\":false},\"type\":\"Memlet\"}},\"dst\":\"9\",\"dst_connector\":\"in_A2\",\"src\":\"6\",\"src_connector\":\"OUT_A\",\"type\":\"MultiConnectorEdge\"},{\"attributes\":{\"data\":{\"attributes\":{\"_meta_allow_oob\":{\"category\":\"General\",\"default\":false,\"desc\":\"Bypass out-of-bounds validation\",\"metatype\":\"bool\"},\"_meta_data\":{\"category\":\"General\",\"default\":null,\"desc\":\"Data descriptor attached to this memlet\",\"metatype\":\"DataProperty\"},\"_meta_debuginfo\":{\"category\":\"General\",\"default\":{\"end_column\":0,\"end_line\":0,\"filename\":null,\"start_column\":0,\"start_line\":0,\"type\":\"DebugInfo\"},\"desc\":\"Line information to track source and generated code\",\"metatype\":\"DebugInfo\"},\"_meta_dynamic\":{\"category\":\"General\",\"default\":false,\"desc\":\"Is the number of elements moved determined at runtime (e.g., data dependent)\",\"metatype\":\"Property\"},\"_meta_other_subset\":{\"category\":\"General\",\"default\":null,\"desc\":\"Subset of elements after reindexing to the data not attached to this edge (e.g., for offsets and reshaping).\",\"metatype\":\"SubsetProperty\"},\"_meta_subset\":{\"category\":\"General\",\"default\":null,\"desc\":\"Subset of elements to move from the data attached to this edge.\",\"metatype\":\"SubsetProperty\"},\"_meta_volume\":{\"category\":\"General\",\"default\":0,\"desc\":\"The exact number of elements moved using this memlet, or the maximum number if dynamic=True (with 0 as unbounded)\",\"metatype\":\"SymbolicProperty\"},\"_meta_wcr\":{\"category\":\"General\",\"default\":null,\"desc\":\"If set, defines a write-conflict resolution lambda function. The syntax of the lambda function receives two elements: `current` value and `new` value, and returns the value after resolution\",\"metatype\":\"LambdaProperty\"},\"_meta_wcr_nonatomic\":{\"category\":\"General\",\"default\":false,\"desc\":\"If True, always generates non-conflicting (non-atomic) writes in resulting code\",\"metatype\":\"bool\"},\"allow_oob\":false,\"data\":\"Y\",\"debuginfo\":null,\"dst_subset\":{\"ranges\":[{\"end\":\"N/2 - 1\",\"start\":\"0\",\"step\":\"1\",\"tile\":\"1\"}],\"type\":\"Range\"},\"dynamic\":false,\"num_accesses\":\"ceiling(N/2)\",\"other_subset\":null,\"src_subset\":null,\"subset\":{\"ranges\":[{\"end\":\"N/2 - 1\",\"start\":\"0\",\"step\":\"1\",\"tile\":\"1\"}],\"type\":\"Range\"},\"volume\":\"ceiling(N/2)\",\"wcr\":null,\"wcr_nonatomic\":false},\"type\":\"Memlet\"}},\"dst\":\"5\",\"dst_connector\":null,\"src\":\"3\",\"src_connector\":\"OUT_Y\",\"type\":\"MultiConnectorEdge\"},{\"attributes\":{\"data\":{\"attributes\":{\"_meta_allow_oob\":{\"category\":\"General\",\"default\":false,\"desc\":\"Bypass out-of-bounds validation\",\"metatype\":\"bool\"},\"_meta_data\":{\"category\":\"General\",\"default\":null,\"desc\":\"Data descriptor attached to this memlet\",\"metatype\":\"DataProperty\"},\"_meta_debuginfo\":{\"category\":\"General\",\"default\":{\"end_column\":0,\"end_line\":0,\"filename\":null,\"start_column\":0,\"start_line\":0,\"type\":\"DebugInfo\"},\"desc\":\"Line information to track source and generated code\",\"metatype\":\"DebugInfo\"},\"_meta_dynamic\":{\"category\":\"General\",\"default\":false,\"desc\":\"Is the number of elements moved determined at runtime (e.g., data dependent)\",\"metatype\":\"Property\"},\"_meta_other_subset\":{\"category\":\"General\",\"default\":null,\"desc\":\"Subset of elements after reindexing to the data not attached to this edge (e.g., for offsets and reshaping).\",\"metatype\":\"SubsetProperty\"},\"_meta_subset\":{\"category\":\"General\",\"default\":null,\"desc\":\"Subset of elements to move from the data attached to this edge.\",\"metatype\":\"SubsetProperty\"},\"_meta_volume\":{\"category\":\"General\",\"default\":0,\"desc\":\"The exact number of elements moved using this memlet, or the maximum number if dynamic=True (with 0 as unbounded)\",\"metatype\":\"SymbolicProperty\"},\"_meta_wcr\":{\"category\":\"General\",\"default\":null,\"desc\":\"If set, defines a write-conflict resolution lambda function. The syntax of the lambda function receives two elements: `current` value and `new` value, and returns the value after resolution\",\"metatype\":\"LambdaProperty\"},\"_meta_wcr_nonatomic\":{\"category\":\"General\",\"default\":false,\"desc\":\"If True, always generates non-conflicting (non-atomic) writes in resulting code\",\"metatype\":\"bool\"},\"allow_oob\":false,\"data\":\"Y\",\"debuginfo\":null,\"dst_subset\":{\"ranges\":[{\"end\":\"N - 1\",\"start\":\"N/2\",\"step\":\"1\",\"tile\":\"1\"}],\"type\":\"Range\"},\"dynamic\":false,\"num_accesses\":\"ceiling(N/2)\",\"other_subset\":null,\"src_subset\":null,\"subset\":{\"ranges\":[{\"end\":\"N - 1\",\"start\":\"N/2\",\"step\":\"1\",\"tile\":\"1\"}],\"type\":\"Range\"},\"volume\":\"ceiling(N/2)\",\"wcr\":null,\"wcr_nonatomic\":false},\"type\":\"Memlet\"}},\"dst\":\"5\",\"dst_connector\":null,\"src\":\"7\",\"src_connector\":\"OUT_Y\",\"type\":\"MultiConnectorEdge\"},{\"attributes\":{\"data\":{\"attributes\":{\"_meta_allow_oob\":{\"category\":\"General\",\"default\":false,\"desc\":\"Bypass out-of-bounds validation\",\"metatype\":\"bool\"},\"_meta_data\":{\"category\":\"General\",\"default\":null,\"desc\":\"Data descriptor attached to this memlet\",\"metatype\":\"DataProperty\"},\"_meta_debuginfo\":{\"category\":\"General\",\"default\":{\"end_column\":0,\"end_line\":0,\"filename\":null,\"start_column\":0,\"start_line\":0,\"type\":\"DebugInfo\"},\"desc\":\"Line information to track source and generated code\",\"metatype\":\"DebugInfo\"},\"_meta_dynamic\":{\"category\":\"General\",\"default\":false,\"desc\":\"Is the number of elements moved determined at runtime (e.g., data dependent)\",\"metatype\":\"Property\"},\"_meta_other_subset\":{\"category\":\"General\",\"default\":null,\"desc\":\"Subset of elements after reindexing to the data not attached to this edge (e.g., for offsets and reshaping).\",\"metatype\":\"SubsetProperty\"},\"_meta_subset\":{\"category\":\"General\",\"default\":null,\"desc\":\"Subset of elements to move from the data attached to this edge.\",\"metatype\":\"SubsetProperty\"},\"_meta_volume\":{\"category\":\"General\",\"default\":0,\"desc\":\"The exact number of elements moved using this memlet, or the maximum number if dynamic=True (with 0 as unbounded)\",\"metatype\":\"SymbolicProperty\"},\"_meta_wcr\":{\"category\":\"General\",\"default\":null,\"desc\":\"If set, defines a write-conflict resolution lambda function. The syntax of the lambda function receives two elements: `current` value and `new` value, and returns the value after resolution\",\"metatype\":\"LambdaProperty\"},\"_meta_wcr_nonatomic\":{\"category\":\"General\",\"default\":false,\"desc\":\"If True, always generates non-conflicting (non-atomic) writes in resulting code\",\"metatype\":\"bool\"},\"allow_oob\":false,\"data\":\"X\",\"debuginfo\":null,\"dst_subset\":null,\"dynamic\":false,\"num_accesses\":\"1\",\"other_subset\":null,\"src_subset\":{\"ranges\":[{\"end\":\"i\",\"start\":\"i\",\"step\":\"1\",\"tile\":\"1\"}],\"type\":\"Range\"},\"subset\":{\"ranges\":[{\"end\":\"i\",\"start\":\"i\",\"step\":\"1\",\"tile\":\"1\"}],\"type\":\"Range\"},\"volume\":\"1\",\"wcr\":null,\"wcr_nonatomic\":false},\"type\":\"Memlet\"}},\"dst\":\"8\",\"dst_connector\":\"in_X1\",\"src\":\"2\",\"src_connector\":\"OUT___tmp0\",\"type\":\"MultiConnectorEdge\"},{\"attributes\":{\"data\":{\"attributes\":{\"_meta_allow_oob\":{\"category\":\"General\",\"default\":false,\"desc\":\"Bypass out-of-bounds validation\",\"metatype\":\"bool\"},\"_meta_data\":{\"category\":\"General\",\"default\":null,\"desc\":\"Data descriptor attached to this memlet\",\"metatype\":\"DataProperty\"},\"_meta_debuginfo\":{\"category\":\"General\",\"default\":{\"end_column\":0,\"end_line\":0,\"filename\":null,\"start_column\":0,\"start_line\":0,\"type\":\"DebugInfo\"},\"desc\":\"Line information to track source and generated code\",\"metatype\":\"DebugInfo\"},\"_meta_dynamic\":{\"category\":\"General\",\"default\":false,\"desc\":\"Is the number of elements moved determined at runtime (e.g., data dependent)\",\"metatype\":\"Property\"},\"_meta_other_subset\":{\"category\":\"General\",\"default\":null,\"desc\":\"Subset of elements after reindexing to the data not attached to this edge (e.g., for offsets and reshaping).\",\"metatype\":\"SubsetProperty\"},\"_meta_subset\":{\"category\":\"General\",\"default\":null,\"desc\":\"Subset of elements to move from the data attached to this edge.\",\"metatype\":\"SubsetProperty\"},\"_meta_volume\":{\"category\":\"General\",\"default\":0,\"desc\":\"The exact number of elements moved using this memlet, or the maximum number if dynamic=True (with 0 as unbounded)\",\"metatype\":\"SymbolicProperty\"},\"_meta_wcr\":{\"category\":\"General\",\"default\":null,\"desc\":\"If set, defines a write-conflict resolution lambda function. The syntax of the lambda function receives two elements: `current` value and `new` value, and returns the value after resolution\",\"metatype\":\"LambdaProperty\"},\"_meta_wcr_nonatomic\":{\"category\":\"General\",\"default\":false,\"desc\":\"If True, always generates non-conflicting (non-atomic) writes in resulting code\",\"metatype\":\"bool\"},\"allow_oob\":false,\"data\":\"Y\",\"debuginfo\":null,\"dst_subset\":null,\"dynamic\":false,\"num_accesses\":\"1\",\"other_subset\":null,\"src_subset\":{\"ranges\":[{\"end\":\"i\",\"start\":\"i\",\"step\":\"1\",\"tile\":\"1\"}],\"type\":\"Range\"},\"subset\":{\"ranges\":[{\"end\":\"i\",\"start\":\"i\",\"step\":\"1\",\"tile\":\"1\"}],\"type\":\"Range\"},\"volume\":\"1\",\"wcr\":null,\"wcr_nonatomic\":false},\"type\":\"Memlet\"}},\"dst\":\"8\",\"dst_connector\":\"in_Y1\",\"src\":\"2\",\"src_connector\":\"OUT___tmp1\",\"type\":\"MultiConnectorEdge\"},{\"attributes\":{\"data\":{\"attributes\":{\"_meta_allow_oob\":{\"category\":\"General\",\"default\":false,\"desc\":\"Bypass out-of-bounds validation\",\"metatype\":\"bool\"},\"_meta_data\":{\"category\":\"General\",\"default\":null,\"desc\":\"Data descriptor attached to this memlet\",\"metatype\":\"DataProperty\"},\"_meta_debuginfo\":{\"category\":\"General\",\"default\":{\"end_column\":0,\"end_line\":0,\"filename\":null,\"start_column\":0,\"start_line\":0,\"type\":\"DebugInfo\"},\"desc\":\"Line information to track source and generated code\",\"metatype\":\"DebugInfo\"},\"_meta_dynamic\":{\"category\":\"General\",\"default\":false,\"desc\":\"Is the number of elements moved determined at runtime (e.g., data dependent)\",\"metatype\":\"Property\"},\"_meta_other_subset\":{\"category\":\"General\",\"default\":null,\"desc\":\"Subset of elements after reindexing to the data not attached to this edge (e.g., for offsets and reshaping).\",\"metatype\":\"SubsetProperty\"},\"_meta_subset\":{\"category\":\"General\",\"default\":null,\"desc\":\"Subset of elements to move from the data attached to this edge.\",\"metatype\":\"SubsetProperty\"},\"_meta_volume\":{\"category\":\"General\",\"default\":0,\"desc\":\"The exact number of elements moved using this memlet, or the maximum number if dynamic=True (with 0 as unbounded)\",\"metatype\":\"SymbolicProperty\"},\"_meta_wcr\":{\"category\":\"General\",\"default\":null,\"desc\":\"If set, defines a write-conflict resolution lambda function. The syntax of the lambda function receives two elements: `current` value and `new` value, and returns the value after resolution\",\"metatype\":\"LambdaProperty\"},\"_meta_wcr_nonatomic\":{\"category\":\"General\",\"default\":false,\"desc\":\"If True, always generates non-conflicting (non-atomic) writes in resulting code\",\"metatype\":\"bool\"},\"allow_oob\":false,\"data\":\"X\",\"debuginfo\":null,\"dst_subset\":null,\"dynamic\":false,\"num_accesses\":\"1\",\"other_subset\":null,\"src_subset\":{\"ranges\":[{\"end\":\"N/2 + i\",\"start\":\"N/2 + i\",\"step\":\"1\",\"tile\":\"1\"}],\"type\":\"Range\"},\"subset\":{\"ranges\":[{\"end\":\"N/2 + i\",\"start\":\"N/2 + i\",\"step\":\"1\",\"tile\":\"1\"}],\"type\":\"Range\"},\"volume\":\"1\",\"wcr\":null,\"wcr_nonatomic\":false},\"type\":\"Memlet\"}},\"dst\":\"9\",\"dst_connector\":\"in_X2\",\"src\":\"6\",\"src_connector\":\"OUT___tmp2\",\"type\":\"MultiConnectorEdge\"},{\"attributes\":{\"data\":{\"attributes\":{\"_meta_allow_oob\":{\"category\":\"General\",\"default\":false,\"desc\":\"Bypass out-of-bounds validation\",\"metatype\":\"bool\"},\"_meta_data\":{\"category\":\"General\",\"default\":null,\"desc\":\"Data descriptor attached to this memlet\",\"metatype\":\"DataProperty\"},\"_meta_debuginfo\":{\"category\":\"General\",\"default\":{\"end_column\":0,\"end_line\":0,\"filename\":null,\"start_column\":0,\"start_line\":0,\"type\":\"DebugInfo\"},\"desc\":\"Line information to track source and generated code\",\"metatype\":\"DebugInfo\"},\"_meta_dynamic\":{\"category\":\"General\",\"default\":false,\"desc\":\"Is the number of elements moved determined at runtime (e.g., data dependent)\",\"metatype\":\"Property\"},\"_meta_other_subset\":{\"category\":\"General\",\"default\":null,\"desc\":\"Subset of elements after reindexing to the data not attached to this edge (e.g., for offsets and reshaping).\",\"metatype\":\"SubsetProperty\"},\"_meta_subset\":{\"category\":\"General\",\"default\":null,\"desc\":\"Subset of elements to move from the data attached to this edge.\",\"metatype\":\"SubsetProperty\"},\"_meta_volume\":{\"category\":\"General\",\"default\":0,\"desc\":\"The exact number of elements moved using this memlet, or the maximum number if dynamic=True (with 0 as unbounded)\",\"metatype\":\"SymbolicProperty\"},\"_meta_wcr\":{\"category\":\"General\",\"default\":null,\"desc\":\"If set, defines a write-conflict resolution lambda function. The syntax of the lambda function receives two elements: `current` value and `new` value, and returns the value after resolution\",\"metatype\":\"LambdaProperty\"},\"_meta_wcr_nonatomic\":{\"category\":\"General\",\"default\":false,\"desc\":\"If True, always generates non-conflicting (non-atomic) writes in resulting code\",\"metatype\":\"bool\"},\"allow_oob\":false,\"data\":\"Y\",\"debuginfo\":null,\"dst_subset\":null,\"dynamic\":false,\"num_accesses\":\"1\",\"other_subset\":null,\"src_subset\":{\"ranges\":[{\"end\":\"N/2 + i\",\"start\":\"N/2 + i\",\"step\":\"1\",\"tile\":\"1\"}],\"type\":\"Range\"},\"subset\":{\"ranges\":[{\"end\":\"N/2 + i\",\"start\":\"N/2 + i\",\"step\":\"1\",\"tile\":\"1\"}],\"type\":\"Range\"},\"volume\":\"1\",\"wcr\":null,\"wcr_nonatomic\":false},\"type\":\"Memlet\"}},\"dst\":\"9\",\"dst_connector\":\"in_Y2\",\"src\":\"6\",\"src_connector\":\"OUT___tmp3\",\"type\":\"MultiConnectorEdge\"},{\"attributes\":{\"data\":{\"attributes\":{\"_meta_allow_oob\":{\"category\":\"General\",\"default\":false,\"desc\":\"Bypass out-of-bounds validation\",\"metatype\":\"bool\"},\"_meta_data\":{\"category\":\"General\",\"default\":null,\"desc\":\"Data descriptor attached to this memlet\",\"metatype\":\"DataProperty\"},\"_meta_debuginfo\":{\"category\":\"General\",\"default\":{\"end_column\":0,\"end_line\":0,\"filename\":null,\"start_column\":0,\"start_line\":0,\"type\":\"DebugInfo\"},\"desc\":\"Line information to track source and generated code\",\"metatype\":\"DebugInfo\"},\"_meta_dynamic\":{\"category\":\"General\",\"default\":false,\"desc\":\"Is the number of elements moved determined at runtime (e.g., data dependent)\",\"metatype\":\"Property\"},\"_meta_other_subset\":{\"category\":\"General\",\"default\":null,\"desc\":\"Subset of elements after reindexing to the data not attached to this edge (e.g., for offsets and reshaping).\",\"metatype\":\"SubsetProperty\"},\"_meta_subset\":{\"category\":\"General\",\"default\":null,\"desc\":\"Subset of elements to move from the data attached to this edge.\",\"metatype\":\"SubsetProperty\"},\"_meta_volume\":{\"category\":\"General\",\"default\":0,\"desc\":\"The exact number of elements moved using this memlet, or the maximum number if dynamic=True (with 0 as unbounded)\",\"metatype\":\"SymbolicProperty\"},\"_meta_wcr\":{\"category\":\"General\",\"default\":null,\"desc\":\"If set, defines a write-conflict resolution lambda function. The syntax of the lambda function receives two elements: `current` value and `new` value, and returns the value after resolution\",\"metatype\":\"LambdaProperty\"},\"_meta_wcr_nonatomic\":{\"category\":\"General\",\"default\":false,\"desc\":\"If True, always generates non-conflicting (non-atomic) writes in resulting code\",\"metatype\":\"bool\"},\"allow_oob\":false,\"data\":\"Y\",\"debuginfo\":null,\"dst_subset\":{\"ranges\":[{\"end\":\"i\",\"start\":\"i\",\"step\":\"1\",\"tile\":\"1\"}],\"type\":\"Range\"},\"dynamic\":false,\"num_accesses\":\"1\",\"other_subset\":null,\"src_subset\":null,\"subset\":{\"ranges\":[{\"end\":\"i\",\"start\":\"i\",\"step\":\"1\",\"tile\":\"1\"}],\"type\":\"Range\"},\"volume\":\"1\",\"wcr\":null,\"wcr_nonatomic\":false},\"type\":\"Memlet\"}},\"dst\":\"3\",\"dst_connector\":\"IN_Y\",\"src\":\"8\",\"src_connector\":\"out1\",\"type\":\"MultiConnectorEdge\"},{\"attributes\":{\"data\":{\"attributes\":{\"_meta_allow_oob\":{\"category\":\"General\",\"default\":false,\"desc\":\"Bypass out-of-bounds validation\",\"metatype\":\"bool\"},\"_meta_data\":{\"category\":\"General\",\"default\":null,\"desc\":\"Data descriptor attached to this memlet\",\"metatype\":\"DataProperty\"},\"_meta_debuginfo\":{\"category\":\"General\",\"default\":{\"end_column\":0,\"end_line\":0,\"filename\":null,\"start_column\":0,\"start_line\":0,\"type\":\"DebugInfo\"},\"desc\":\"Line information to track source and generated code\",\"metatype\":\"DebugInfo\"},\"_meta_dynamic\":{\"category\":\"General\",\"default\":false,\"desc\":\"Is the number of elements moved determined at runtime (e.g., data dependent)\",\"metatype\":\"Property\"},\"_meta_other_subset\":{\"category\":\"General\",\"default\":null,\"desc\":\"Subset of elements after reindexing to the data not attached to this edge (e.g., for offsets and reshaping).\",\"metatype\":\"SubsetProperty\"},\"_meta_subset\":{\"category\":\"General\",\"default\":null,\"desc\":\"Subset of elements to move from the data attached to this edge.\",\"metatype\":\"SubsetProperty\"},\"_meta_volume\":{\"category\":\"General\",\"default\":0,\"desc\":\"The exact number of elements moved using this memlet, or the maximum number if dynamic=True (with 0 as unbounded)\",\"metatype\":\"SymbolicProperty\"},\"_meta_wcr\":{\"category\":\"General\",\"default\":null,\"desc\":\"If set, defines a write-conflict resolution lambda function. The syntax of the lambda function receives two elements: `current` value and `new` value, and returns the value after resolution\",\"metatype\":\"LambdaProperty\"},\"_meta_wcr_nonatomic\":{\"category\":\"General\",\"default\":false,\"desc\":\"If True, always generates non-conflicting (non-atomic) writes in resulting code\",\"metatype\":\"bool\"},\"allow_oob\":false,\"data\":\"Y\",\"debuginfo\":null,\"dst_subset\":{\"ranges\":[{\"end\":\"N/2 + i\",\"start\":\"N/2 + i\",\"step\":\"1\",\"tile\":\"1\"}],\"type\":\"Range\"},\"dynamic\":false,\"num_accesses\":\"1\",\"other_subset\":null,\"src_subset\":null,\"subset\":{\"ranges\":[{\"end\":\"N/2 + i\",\"start\":\"N/2 + i\",\"step\":\"1\",\"tile\":\"1\"}],\"type\":\"Range\"},\"volume\":\"1\",\"wcr\":null,\"wcr_nonatomic\":false},\"type\":\"Memlet\"}},\"dst\":\"7\",\"dst_connector\":\"IN_Y\",\"src\":\"9\",\"src_connector\":\"out2\",\"type\":\"MultiConnectorEdge\"}],\"id\":0,\"label\":\"slice_X_8\",\"nodes\":[{\"attributes\":{\"_meta_access\":{\"category\":\"General\",\"default\":\"ReadWrite\",\"desc\":\"Type of access to this array\",\"metatype\":\"AccessType\"},\"_meta_data\":{\"category\":\"General\",\"default\":null,\"desc\":\"Data (array, stream, scalar) to access\",\"metatype\":\"DataProperty\"},\"_meta_debuginfo\":{\"category\":\"General\",\"default\":{\"end_column\":0,\"end_line\":0,\"filename\":null,\"start_column\":0,\"start_line\":0,\"type\":\"DebugInfo\"},\"desc\":\"\",\"metatype\":\"DebugInfo\"},\"_meta_in_connectors\":{\"category\":\"General\",\"default\":{},\"desc\":\"A set of input connectors for this node.\",\"metatype\":\"dict\"},\"_meta_out_connectors\":{\"category\":\"General\",\"default\":{},\"desc\":\"A set of output connectors for this node.\",\"metatype\":\"dict\"},\"_meta_setzero\":{\"category\":\"General\",\"default\":false,\"desc\":\"Initialize to zero\",\"metatype\":\"bool\"},\"access\":\"ReadWrite\",\"data\":\"X\",\"debuginfo\":{\"end_column\":9,\"end_line\":8,\"filename\":\"/var/folders/fh/hmjqvm896lq967r6bq0kfnjc0000gn/T/tmplp5hl0c4/fake.py\",\"start_column\":9,\"start_line\":8,\"type\":\"DebugInfo\"},\"in_connectors\":{},\"out_connectors\":{},\"setzero\":false},\"id\":0,\"label\":\"X\",\"scope_entry\":null,\"scope_exit\":null,\"type\":\"AccessNode\"},{\"attributes\":{\"_meta_access\":{\"category\":\"General\",\"default\":\"ReadWrite\",\"desc\":\"Type of access to this array\",\"metatype\":\"AccessType\"},\"_meta_data\":{\"category\":\"General\",\"default\":null,\"desc\":\"Data (array, stream, scalar) to access\",\"metatype\":\"DataProperty\"},\"_meta_debuginfo\":{\"category\":\"General\",\"default\":{\"end_column\":0,\"end_line\":0,\"filename\":null,\"start_column\":0,\"start_line\":0,\"type\":\"DebugInfo\"},\"desc\":\"\",\"metatype\":\"DebugInfo\"},\"_meta_in_connectors\":{\"category\":\"General\",\"default\":{},\"desc\":\"A set of input connectors for this node.\",\"metatype\":\"dict\"},\"_meta_out_connectors\":{\"category\":\"General\",\"default\":{},\"desc\":\"A set of output connectors for this node.\",\"metatype\":\"dict\"},\"_meta_setzero\":{\"category\":\"General\",\"default\":false,\"desc\":\"Initialize to zero\",\"metatype\":\"bool\"},\"access\":\"ReadWrite\",\"data\":\"Y\",\"debuginfo\":{\"end_column\":9,\"end_line\":9,\"filename\":\"/var/folders/fh/hmjqvm896lq967r6bq0kfnjc0000gn/T/tmplp5hl0c4/fake.py\",\"start_column\":9,\"start_line\":9,\"type\":\"DebugInfo\"},\"in_connectors\":{},\"out_connectors\":{},\"setzero\":false},\"id\":1,\"label\":\"Y\",\"scope_entry\":null,\"scope_exit\":null,\"type\":\"AccessNode\"},{\"attributes\":{\"_meta_collapse\":{\"category\":\"General\",\"default\":1,\"desc\":\"How many dimensions to collapse into the parallel range\",\"indirected\":true,\"metatype\":\"int\"},\"_meta_debuginfo\":{\"category\":\"General\",\"default\":{\"end_column\":0,\"end_line\":0,\"filename\":null,\"start_column\":0,\"start_line\":0,\"type\":\"DebugInfo\"},\"desc\":\"\",\"indirected\":true,\"metatype\":\"DebugInfo\"},\"_meta_in_connectors\":{\"category\":\"General\",\"default\":{},\"desc\":\"A set of input connectors for this node.\",\"metatype\":\"dict\"},\"_meta_instrument\":{\"category\":\"General\",\"default\":\"No_Instrumentation\",\"desc\":\"Measure execution statistics with given method\",\"indirected\":true,\"metatype\":\"InstrumentationType\"},\"_meta_is_collapsed\":{\"category\":\"General\",\"default\":false,\"desc\":\"Show this node/scope/state as collapsed\",\"indirected\":true,\"metatype\":\"bool\"},\"_meta_label\":{\"category\":\"General\",\"default\":\"\",\"desc\":\"Label of the map\",\"indirected\":true,\"metatype\":\"str\"},\"_meta_out_connectors\":{\"category\":\"General\",\"default\":{},\"desc\":\"A set of output connectors for this node.\",\"metatype\":\"dict\"},\"_meta_params\":{\"category\":\"General\",\"default\":[],\"desc\":\"Mapped parameters\",\"indirected\":true,\"metatype\":\"list\"},\"_meta_range\":{\"category\":\"General\",\"default\":{\"ranges\":[],\"type\":\"Range\"},\"desc\":\"Ranges of map parameters\",\"indirected\":true,\"metatype\":\"Range\"},\"_meta_schedule\":{\"category\":\"General\",\"default\":\"Default\",\"desc\":\"Map schedule\",\"indirected\":true,\"metatype\":\"ScheduleType\"},\"_meta_unroll\":{\"category\":\"General\",\"default\":false,\"desc\":\"Map unrolling\",\"indirected\":true,\"metatype\":\"bool\"},\"collapse\":1,\"debuginfo\":{\"end_column\":4,\"end_line\":15,\"filename\":\"/var/folders/fh/hmjqvm896lq967r6bq0kfnjc0000gn/T/tmplp5hl0c4/fake.py\",\"start_column\":4,\"start_line\":15,\"type\":\"DebugInfo\"},\"in_connectors\":{\"IN_A\":null,\"IN___tmp0\":null,\"IN___tmp1\":null},\"instrument\":\"No_Instrumentation\",\"is_collapsed\":false,\"label\":\"multiplication\",\"out_connectors\":{\"OUT_A\":null,\"OUT___tmp0\":null,\"OUT___tmp1\":null},\"params\":[\"i\"],\"range\":{\"ranges\":[{\"end\":\"N/2 - 1\",\"start\":\"0\",\"step\":\"1\",\"tile\":\"1\"}],\"type\":\"Range\"},\"schedule\":\"Default\",\"unroll\":false},\"id\":2,\"label\":\"multiplication[i=0:N/2]\",\"scope_entry\":null,\"scope_exit\":\"3\",\"type\":\"MapEntry\"},{\"attributes\":{\"_meta_in_connectors\":{\"category\":\"General\",\"default\":{},\"desc\":\"A set of input connectors for this node.\",\"metatype\":\"dict\"},\"_meta_out_connectors\":{\"category\":\"General\",\"default\":{},\"desc\":\"A set of output connectors for this node.\",\"metatype\":\"dict\"},\"in_connectors\":{\"IN_Y\":null},\"out_connectors\":{\"OUT_Y\":null}},\"id\":3,\"label\":\"multiplication[i=0:N/2]\",\"scope_entry\":\"2\",\"scope_exit\":\"3\",\"type\":\"MapExit\"},{\"attributes\":{\"_meta_access\":{\"category\":\"General\",\"default\":\"ReadWrite\",\"desc\":\"Type of access to this array\",\"metatype\":\"AccessType\"},\"_meta_data\":{\"category\":\"General\",\"default\":null,\"desc\":\"Data (array, stream, scalar) to access\",\"metatype\":\"DataProperty\"},\"_meta_debuginfo\":{\"category\":\"General\",\"default\":{\"end_column\":0,\"end_line\":0,\"filename\":null,\"start_column\":0,\"start_line\":0,\"type\":\"DebugInfo\"},\"desc\":\"\",\"metatype\":\"DebugInfo\"},\"_meta_in_connectors\":{\"category\":\"General\",\"default\":{},\"desc\":\"A set of input connectors for this node.\",\"metatype\":\"dict\"},\"_meta_out_connectors\":{\"category\":\"General\",\"default\":{},\"desc\":\"A set of output connectors for this node.\",\"metatype\":\"dict\"},\"_meta_setzero\":{\"category\":\"General\",\"default\":false,\"desc\":\"Initialize to zero\",\"metatype\":\"bool\"},\"access\":\"ReadWrite\",\"data\":\"A\",\"debuginfo\":{\"end_column\":4,\"end_line\":15,\"filename\":\"/var/folders/fh/hmjqvm896lq967r6bq0kfnjc0000gn/T/tmplp5hl0c4/fake.py\",\"start_column\":4,\"start_line\":15,\"type\":\"DebugInfo\"},\"in_connectors\":{},\"out_connectors\":{},\"setzero\":false},\"id\":4,\"label\":\"A\",\"scope_entry\":null,\"scope_exit\":null,\"type\":\"AccessNode\"},{\"attributes\":{\"_meta_access\":{\"category\":\"General\",\"default\":\"ReadWrite\",\"desc\":\"Type of access to this array\",\"metatype\":\"AccessType\"},\"_meta_data\":{\"category\":\"General\",\"default\":null,\"desc\":\"Data (array, stream, scalar) to access\",\"metatype\":\"DataProperty\"},\"_meta_debuginfo\":{\"category\":\"General\",\"default\":{\"end_column\":0,\"end_line\":0,\"filename\":null,\"start_column\":0,\"start_line\":0,\"type\":\"DebugInfo\"},\"desc\":\"\",\"metatype\":\"DebugInfo\"},\"_meta_in_connectors\":{\"category\":\"General\",\"default\":{},\"desc\":\"A set of input connectors for this node.\",\"metatype\":\"dict\"},\"_meta_out_connectors\":{\"category\":\"General\",\"default\":{},\"desc\":\"A set of output connectors for this node.\",\"metatype\":\"dict\"},\"_meta_setzero\":{\"category\":\"General\",\"default\":false,\"desc\":\"Initialize to zero\",\"metatype\":\"bool\"},\"access\":\"WriteOnly\",\"data\":\"Y\",\"debuginfo\":{\"end_column\":4,\"end_line\":15,\"filename\":\"/var/folders/fh/hmjqvm896lq967r6bq0kfnjc0000gn/T/tmplp5hl0c4/fake.py\",\"start_column\":4,\"start_line\":15,\"type\":\"DebugInfo\"},\"in_connectors\":{},\"out_connectors\":{},\"setzero\":false},\"id\":5,\"label\":\"Y\",\"scope_entry\":null,\"scope_exit\":null,\"type\":\"AccessNode\"},{\"attributes\":{\"_meta_collapse\":{\"category\":\"General\",\"default\":1,\"desc\":\"How many dimensions to collapse into the parallel range\",\"indirected\":true,\"metatype\":\"int\"},\"_meta_debuginfo\":{\"category\":\"General\",\"default\":{\"end_column\":0,\"end_line\":0,\"filename\":null,\"start_column\":0,\"start_line\":0,\"type\":\"DebugInfo\"},\"desc\":\"\",\"indirected\":true,\"metatype\":\"DebugInfo\"},\"_meta_in_connectors\":{\"category\":\"General\",\"default\":{},\"desc\":\"A set of input connectors for this node.\",\"metatype\":\"dict\"},\"_meta_instrument\":{\"category\":\"General\",\"default\":\"No_Instrumentation\",\"desc\":\"Measure execution statistics with given method\",\"indirected\":true,\"metatype\":\"InstrumentationType\"},\"_meta_is_collapsed\":{\"category\":\"General\",\"default\":false,\"desc\":\"Show this node/scope/state as collapsed\",\"indirected\":true,\"metatype\":\"bool\"},\"_meta_label\":{\"category\":\"General\",\"default\":\"\",\"desc\":\"Label of the map\",\"indirected\":true,\"metatype\":\"str\"},\"_meta_out_connectors\":{\"category\":\"General\",\"default\":{},\"desc\":\"A set of output connectors for this node.\",\"metatype\":\"dict\"},\"_meta_params\":{\"category\":\"General\",\"default\":[],\"desc\":\"Mapped parameters\",\"indirected\":true,\"metatype\":\"list\"},\"_meta_range\":{\"category\":\"General\",\"default\":{\"ranges\":[],\"type\":\"Range\"},\"desc\":\"Ranges of map parameters\",\"indirected\":true,\"metatype\":\"Range\"},\"_meta_schedule\":{\"category\":\"General\",\"default\":\"Default\",\"desc\":\"Map schedule\",\"indirected\":true,\"metatype\":\"ScheduleType\"},\"_meta_unroll\":{\"category\":\"General\",\"default\":false,\"desc\":\"Map unrolling\",\"indirected\":true,\"metatype\":\"bool\"},\"collapse\":1,\"debuginfo\":{\"end_column\":4,\"end_line\":24,\"filename\":\"/var/folders/fh/hmjqvm896lq967r6bq0kfnjc0000gn/T/tmplp5hl0c4/fake.py\",\"start_column\":4,\"start_line\":24,\"type\":\"DebugInfo\"},\"in_connectors\":{\"IN_A\":null,\"IN___tmp2\":null,\"IN___tmp3\":null},\"instrument\":\"No_Instrumentation\",\"is_collapsed\":false,\"label\":\"multiplication\",\"out_connectors\":{\"OUT_A\":null,\"OUT___tmp2\":null,\"OUT___tmp3\":null},\"params\":[\"i\"],\"range\":{\"ranges\":[{\"end\":\"N/2 - 1\",\"start\":\"0\",\"step\":\"1\",\"tile\":\"1\"}],\"type\":\"Range\"},\"schedule\":\"Default\",\"unroll\":false},\"id\":6,\"label\":\"multiplication[i=0:N/2]\",\"scope_entry\":null,\"scope_exit\":\"7\",\"type\":\"MapEntry\"},{\"attributes\":{\"_meta_in_connectors\":{\"category\":\"General\",\"default\":{},\"desc\":\"A set of input connectors for this node.\",\"metatype\":\"dict\"},\"_meta_out_connectors\":{\"category\":\"General\",\"default\":{},\"desc\":\"A set of output connectors for this node.\",\"metatype\":\"dict\"},\"in_connectors\":{\"IN_Y\":null},\"out_connectors\":{\"OUT_Y\":null}},\"id\":7,\"label\":\"multiplication[i=0:N/2]\",\"scope_entry\":\"6\",\"scope_exit\":\"7\",\"type\":\"MapExit\"},{\"attributes\":{\"_meta_code\":{\"category\":\"General\",\"default\":{\"language\":\"Python\",\"string_data\":\"\"},\"desc\":\"Tasklet code\",\"metatype\":\"CodeBlock\"},\"_meta_debuginfo\":{\"category\":\"General\",\"default\":{\"end_column\":0,\"end_line\":0,\"filename\":null,\"start_column\":0,\"start_line\":0,\"type\":\"DebugInfo\"},\"desc\":\"\",\"metatype\":\"DebugInfo\"},\"_meta_environments\":{\"category\":\"General\",\"default\":[],\"desc\":\"Environments required by CMake to build and run this code node.\",\"metatype\":\"set\"},\"_meta_in_connectors\":{\"category\":\"General\",\"default\":{},\"desc\":\"A set of input connectors for this node.\",\"metatype\":\"dict\"},\"_meta_instrument\":{\"category\":\"General\",\"default\":\"No_Instrumentation\",\"desc\":\"Measure execution statistics with given method\",\"metatype\":\"InstrumentationType\"},\"_meta_label\":{\"category\":\"General\",\"default\":\"\",\"desc\":\"Name of the CodeNode\",\"metatype\":\"str\"},\"_meta_location\":{\"category\":\"General\",\"default\":{},\"desc\":\"Full storage location identifier (e.g., rank, GPU ID)\",\"metatype\":\"dict\"},\"_meta_out_connectors\":{\"category\":\"General\",\"default\":{},\"desc\":\"A set of output connectors for this node.\",\"metatype\":\"dict\"},\"code\":{\"language\":\"Python\",\"string_data\":\"out1 = ((in_A1 * in_X1) + in_Y1)\"},\"debuginfo\":{\"end_column\":8,\"end_line\":21,\"filename\":\"/var/folders/fh/hmjqvm896lq967r6bq0kfnjc0000gn/T/tmplp5hl0c4/fake.py\",\"start_column\":4,\"start_line\":15,\"type\":\"DebugInfo\"},\"environments\":[],\"in_connectors\":{\"in_A1\":null,\"in_X1\":null,\"in_Y1\":null},\"instrument\":\"No_Instrumentation\",\"label\":\"multiplication\",\"location\":{},\"out_connectors\":{\"out1\":null}},\"id\":8,\"label\":\"multiplication\",\"scope_entry\":\"2\",\"scope_exit\":\"3\",\"type\":\"Tasklet\"},{\"attributes\":{\"_meta_code\":{\"category\":\"General\",\"default\":{\"language\":\"Python\",\"string_data\":\"\"},\"desc\":\"Tasklet code\",\"metatype\":\"CodeBlock\"},\"_meta_debuginfo\":{\"category\":\"General\",\"default\":{\"end_column\":0,\"end_line\":0,\"filename\":null,\"start_column\":0,\"start_line\":0,\"type\":\"DebugInfo\"},\"desc\":\"\",\"metatype\":\"DebugInfo\"},\"_meta_environments\":{\"category\":\"General\",\"default\":[],\"desc\":\"Environments required by CMake to build and run this code node.\",\"metatype\":\"set\"},\"_meta_in_connectors\":{\"category\":\"General\",\"default\":{},\"desc\":\"A set of input connectors for this node.\",\"metatype\":\"dict\"},\"_meta_instrument\":{\"category\":\"General\",\"default\":\"No_Instrumentation\",\"desc\":\"Measure execution statistics with given method\",\"metatype\":\"InstrumentationType\"},\"_meta_label\":{\"category\":\"General\",\"default\":\"\",\"desc\":\"Name of the CodeNode\",\"metatype\":\"str\"},\"_meta_location\":{\"category\":\"General\",\"default\":{},\"desc\":\"Full storage location identifier (e.g., rank, GPU ID)\",\"metatype\":\"dict\"},\"_meta_out_connectors\":{\"category\":\"General\",\"default\":{},\"desc\":\"A set of output connectors for this node.\",\"metatype\":\"dict\"},\"code\":{\"language\":\"Python\",\"string_data\":\"out2 = ((in_A2 * in_X2) + in_Y2)\"},\"debuginfo\":{\"end_column\":8,\"end_line\":30,\"filename\":\"/var/folders/fh/hmjqvm896lq967r6bq0kfnjc0000gn/T/tmplp5hl0c4/fake.py\",\"start_column\":4,\"start_line\":24,\"type\":\"DebugInfo\"},\"environments\":[],\"in_connectors\":{\"in_A2\":null,\"in_X2\":null,\"in_Y2\":null},\"instrument\":\"No_Instrumentation\",\"label\":\"multiplication\",\"location\":{},\"out_connectors\":{\"out2\":null}},\"id\":9,\"label\":\"multiplication\",\"scope_entry\":\"6\",\"scope_exit\":\"7\",\"type\":\"Tasklet\"}],\"scope_dict\":{\"2\":[3,8],\"6\":[7,9],\"-1\":[0,1,2,4,5,6]},\"type\":\"SDFGState\"}],\"sdfg_list_id\":0,\"type\":\"SDFG\"}","symbols":{"N":"int32"},"transformation_hist":[{"_meta__subgraph":{"category":"(Debug)","default":{},"desc":"","metatype":"dict"},"_meta_expr_index":{"category":"(Debug)","default":0,"desc":"","metatype":"int"},"_meta_fullcopy":{"category":"General","default":false,"desc":"Copy whole arrays rather than used subset","metatype":"bool"},"_meta_register_trans":{"category":"General","default":false,"desc":"Make all transients inside GPU maps registers","metatype":"bool"},"_meta_sdfg_id":{"category":"(Debug)","default":0,"desc":"","metatype":"int"},"_meta_sequential_innermaps":{"category":"General","default":false,"desc":"Make all internal maps Sequential","metatype":"bool"},"_meta_state_id":{"category":"(Debug)","default":0,"desc":"","metatype":"int"},"_meta_toplevel_trans":{"category":"General","default":false,"desc":"Make all GPU transients top-level","metatype":"bool"},"_subgraph":{"0":2},"expr_index":0,"fullcopy":false,"register_trans":false,"sdfg_id":0,"sequential_innermaps":false,"state_id":0,"toplevel_trans":false,"transformation":"GPUTransformMap","type":"Transformation"},{"_meta__subgraph":{"category":"(Debug)","default":{},"desc":"","metatype":"dict"},"_meta_expr_index":{"category":"(Debug)","default":0,"desc":"","metatype":"int"},"_meta_fullcopy":{"category":"General","default":false,"desc":"Copy whole arrays rather than used subset","metatype":"bool"},"_meta_register_trans":{"category":"General","default":false,"desc":"Make all transients inside GPU maps registers","metatype":"bool"},"_meta_sdfg_id":{"category":"(Debug)","default":0,"desc":"","metatype":"int"},"_meta_sequential_innermaps":{"category":"General","default":false,"desc":"Make all internal maps Sequential","metatype":"bool"},"_meta_state_id":{"category":"(Debug)","default":0,"desc":"","metatype":"int"},"_meta_toplevel_trans":{"category":"General","default":false,"desc":"Make all GPU transients top-level","metatype":"bool"},"_subgraph":{"0":4},"expr_index":0,"fullcopy":false,"register_trans":false,"sdfg_id":0,"sequential_innermaps":false,"state_id":0,"toplevel_trans":false,"transformation":"GPUTransformMap","type":"Transformation"}]},"edges":[],"nodes":[{"attributes":{"_meta_dynamic_executions":{"category":"General","default":true,"desc":"The number of executions of this state is dynamic","metatype":"bool"},"_meta_executions":{"category":"General","default":0,"desc":"The number of times this state gets executed (0 stands for unbounded)","metatype":"SymbolicProperty"},"_meta_instrument":{"category":"General","default":"No_Instrumentation","desc":"Measure execution statistics with given method","metatype":"InstrumentationType"},"_meta_is_collapsed":{"category":"General","default":false,"desc":"Show this node/scope/state as collapsed","metatype":"bool"},"_meta_location":{"category":"General","default":{},"desc":"Full storage location identifier (e.g., rank, GPU ID)","metatype":"dict"},"_meta_nosync":{"category":"General","default":false,"desc":"Do not synchronize at the end of the state","metatype":"bool"},"_meta_ranges":{"category":"General","default":{},"desc":"Variable ranges, typically within loops","metatype":"dict"},"dynamic_executions":false,"executions":"1","instrument":"No_Instrumentation","is_collapsed":false,"location":{},"nosync":false,"ranges":{}},"collapsed":false,"edges":[{"attributes":{"data":{"attributes":{"_meta_allow_oob":{"category":"General","default":false,"desc":"Bypass out-of-bounds validation","metatype":"bool"},"_meta_data":{"category":"General","default":null,"desc":"Data descriptor attached to this memlet","metatype":"DataProperty"},"_meta_debuginfo":{"category":"General","default":{"end_column":0,"end_line":0,"filename":null,"start_column":0,"start_line":0,"type":"DebugInfo"},"desc":"Line information to track source and generated code","metatype":"DebugInfo"},"_meta_dynamic":{"category":"General","default":false,"desc":"Is the number of elements moved determined at runtime (e.g., data dependent)","metatype":"Property"},"_meta_other_subset":{"category":"General","default":null,"desc":"Subset of elements after reindexing to the data not attached to this edge (e.g., for offsets and reshaping).","metatype":"SubsetProperty"},"_meta_subset":{"category":"General","default":null,"desc":"Subset of elements to move from the data attached to this edge.","metatype":"SubsetProperty"},"_meta_volume":{"category":"General","default":0,"desc":"The exact number of elements moved using this memlet, or the maximum number if dynamic=True (with 0 as unbounded)","metatype":"SymbolicProperty"},"_meta_wcr":{"category":"General","default":null,"desc":"If set, defines a write-conflict resolution lambda function. The syntax of the lambda function receives two elements: `current` value and `new` value, and returns the value after resolution","metatype":"LambdaProperty"},"_meta_wcr_nonatomic":{"category":"General","default":false,"desc":"If True, always generates non-conflicting (non-atomic) writes in resulting code","metatype":"bool"},"allow_oob":false,"data":"X","debuginfo":null,"dst_subset":null,"dynamic":false,"num_accesses":"ceiling(N/2)","other_subset":null,"src_subset":{"ranges":[{"end":"ceiling(N/2) - 1","start":"0","step":"1","tile":"1"}],"type":"Range"},"subset":{"ranges":[{"end":"ceiling(N/2) - 1","start":"0","step":"1","tile":"1"}],"type":"Range"},"volume":"ceiling(N/2)","wcr":null,"wcr_nonatomic":false},"type":"Memlet"}},"dst":"4","dst_connector":null,"src":"0","src_connector":null,"type":"MultiConnectorEdge"},{"attributes":{"data":{"attributes":{"_meta_allow_oob":{"category":"General","default":false,"desc":"Bypass out-of-bounds validation","metatype":"bool"},"_meta_data":{"category":"General","default":null,"desc":"Data descriptor attached to this memlet","metatype":"DataProperty"},"_meta_debuginfo":{"category":"General","default":{"end_column":0,"end_line":0,"filename":null,"start_column":0,"start_line":0,"type":"DebugInfo"},"desc":"Line information to track source and generated code","metatype":"DebugInfo"},"_meta_dynamic":{"category":"General","default":false,"desc":"Is the number of elements moved determined at runtime (e.g., data dependent)","metatype":"Property"},"_meta_other_subset":{"category":"General","default":null,"desc":"Subset of elements after reindexing to the data not attached to this edge (e.g., for offsets and reshaping).","metatype":"SubsetProperty"},"_meta_subset":{"category":"General","default":null,"desc":"Subset of elements to move from the data attached to this edge.","metatype":"SubsetProperty"},"_meta_volume":{"category":"General","default":0,"desc":"The exact number of elements moved using this memlet, or the maximum number if dynamic=True (with 0 as unbounded)","metatype":"SymbolicProperty"},"_meta_wcr":{"category":"General","default":null,"desc":"If set, defines a write-conflict resolution lambda function. The syntax of the lambda function receives two elements: `current` value and `new` value, and returns the value after resolution","metatype":"LambdaProperty"},"_meta_wcr_nonatomic":{"category":"General","default":false,"desc":"If True, always generates non-conflicting (non-atomic) writes in resulting code","metatype":"bool"},"allow_oob":false,"data":"Y","debuginfo":null,"dst_subset":null,"dynamic":false,"num_accesses":"ceiling(N/2)","other_subset":null,"src_subset":{"ranges":[{"end":"ceiling(N/2) - 1","start":"0","step":"1","tile":"1"}],"type":"Range"},"subset":{"ranges":[{"end":"ceiling(N/2) - 1","start":"0","step":"1","tile":"1"}],"type":"Range"},"volume":"ceiling(N/2)","wcr":null,"wcr_nonatomic":false},"type":"Memlet"}},"dst":"5","dst_connector":null,"src":"1","src_connector":null,"type":"MultiConnectorEdge"},{"attributes":{"data":{"attributes":{"_meta_allow_oob":{"category":"General","default":false,"desc":"Bypass out-of-bounds validation","metatype":"bool"},"_meta_data":{"category":"General","default":null,"desc":"Data descriptor attached to this memlet","metatype":"DataProperty"},"_meta_debuginfo":{"category":"General","default":{"end_column":0,"end_line":0,"filename":null,"start_column":0,"start_line":0,"type":"DebugInfo"},"desc":"Line information to track source and generated code","metatype":"DebugInfo"},"_meta_dynamic":{"category":"General","default":false,"desc":"Is the number of elements moved determined at runtime (e.g., data dependent)","metatype":"Property"},"_meta_other_subset":{"category":"General","default":null,"desc":"Subset of elements after reindexing to the data not attached to this edge (e.g., for offsets and reshaping).","metatype":"SubsetProperty"},"_meta_subset":{"category":"General","default":null,"desc":"Subset of elements to move from the data attached to this edge.","metatype":"SubsetProperty"},"_meta_volume":{"category":"General","default":0,"desc":"The exact number of elements moved using this memlet, or the maximum number if dynamic=True (with 0 as unbounded)","metatype":"SymbolicProperty"},"_meta_wcr":{"category":"General","default":null,"desc":"If set, defines a write-conflict resolution lambda function. The syntax of the lambda function receives two elements: `current` value and `new` value, and returns the value after resolution","metatype":"LambdaProperty"},"_meta_wcr_nonatomic":{"category":"General","default":false,"desc":"If True, always generates non-conflicting (non-atomic) writes in resulting code","metatype":"bool"},"allow_oob":false,"data":"Y","debuginfo":null,"dst_subset":{"ranges":[{"end":"ceiling(N/2) - 1","start":"0","step":"1","tile":"1"}],"type":"Range"},"dynamic":false,"num_accesses":"ceiling(N/2)","other_subset":null,"src_subset":null,"subset":{"ranges":[{"end":"ceiling(N/2) - 1","start":"0","step":"1","tile":"1"}],"type":"Range"},"volume":"ceiling(N/2)","wcr":null,"wcr_nonatomic":false},"type":"Memlet"}},"dst":"3","dst_connector":null,"src":"9","src_connector":null,"type":"MultiConnectorEdge"},{"attributes":{"data":{"attributes":{"_meta_allow_oob":{"category":"General","default":false,"desc":"Bypass out-of-bounds validation","metatype":"bool"},"_meta_data":{"category":"General","default":null,"desc":"Data descriptor attached to this memlet","metatype":"DataProperty"},"_meta_debuginfo":{"category":"General","default":{"end_column":0,"end_line":0,"filename":null,"start_column":0,"start_line":0,"type":"DebugInfo"},"desc":"Line information to track source and generated code","metatype":"DebugInfo"},"_meta_dynamic":{"category":"General","default":false,"desc":"Is the number of elements moved determined at runtime (e.g., data dependent)","metatype":"Property"},"_meta_other_subset":{"category":"General","default":null,"desc":"Subset of elements after reindexing to the data not attached to this edge (e.g., for offsets and reshaping).","metatype":"SubsetProperty"},"_meta_subset":{"category":"General","default":null,"desc":"Subset of elements to move from the data attached to this edge.","metatype":"SubsetProperty"},"_meta_volume":{"category":"General","default":0,"desc":"The exact number of elements moved using this memlet, or the maximum number if dynamic=True (with 0 as unbounded)","metatype":"SymbolicProperty"},"_meta_wcr":{"category":"General","default":null,"desc":"If set, defines a write-conflict resolution lambda function. The syntax of the lambda function receives two elements: `current` value and `new` value, and returns the value after resolution","metatype":"LambdaProperty"},"_meta_wcr_nonatomic":{"category":"General","default":false,"desc":"If True, always generates non-conflicting (non-atomic) writes in resulting code","metatype":"bool"},"allow_oob":false,"data":"X","debuginfo":null,"dst_subset":null,"dynamic":false,"num_accesses":"ceiling(N/2)","other_subset":null,"src_subset":{"ranges":[{"end":"N/2 + ceiling(N/2) - 1","start":"N/2","step":"1","tile":"1"}],"type":"Range"},"subset":{"ranges":[{"end":"N/2 + ceiling(N/2) - 1","start":"N/2","step":"1","tile":"1"}],"type":"Range"},"volume":"ceiling(N/2)","wcr":null,"wcr_nonatomic":false},"type":"Memlet"}},"dst":"10","dst_connector":null,"src":"0","src_connector":null,"type":"MultiConnectorEdge"},{"attributes":{"data":{"attributes":{"_meta_allow_oob":{"category":"General","default":false,"desc":"Bypass out-of-bounds validation","metatype":"bool"},"_meta_data":{"category":"General","default":null,"desc":"Data descriptor attached to this memlet","metatype":"DataProperty"},"_meta_debuginfo":{"category":"General","default":{"end_column":0,"end_line":0,"filename":null,"start_column":0,"start_line":0,"type":"DebugInfo"},"desc":"Line information to track source and generated code","metatype":"DebugInfo"},"_meta_dynamic":{"category":"General","default":false,"desc":"Is the number of elements moved determined at runtime (e.g., data dependent)","metatype":"Property"},"_meta_other_subset":{"category":"General","default":null,"desc":"Subset of elements after reindexing to the data not attached to this edge (e.g., for offsets and reshaping).","metatype":"SubsetProperty"},"_meta_subset":{"category":"General","default":null,"desc":"Subset of elements to move from the data attached to this edge.","metatype":"SubsetProperty"},"_meta_volume":{"category":"General","default":0,"desc":"The exact number of elements moved using this memlet, or the maximum number if dynamic=True (with 0 as unbounded)","metatype":"SymbolicProperty"},"_meta_wcr":{"category":"General","default":null,"desc":"If set, defines a write-conflict resolution lambda function. The syntax of the lambda function receives two elements: `current` value and `new` value, and returns the value after resolution","metatype":"LambdaProperty"},"_meta_wcr_nonatomic":{"category":"General","default":false,"desc":"If True, always generates non-conflicting (non-atomic) writes in resulting code","metatype":"bool"},"allow_oob":false,"data":"Y","debuginfo":null,"dst_subset":null,"dynamic":false,"num_accesses":"ceiling(N/2)","other_subset":null,"src_subset":{"ranges":[{"end":"N/2 + ceiling(N/2) - 1","start":"N/2","step":"1","tile":"1"}],"type":"Range"},"subset":{"ranges":[{"end":"N/2 + ceiling(N/2) - 1","start":"N/2","step":"1","tile":"1"}],"type":"Range"},"volume":"ceiling(N/2)","wcr":null,"wcr_nonatomic":false},"type":"Memlet"}},"dst":"11","dst_connector":null,"src":"1","src_connector":null,"type":"MultiConnectorEdge"},{"attributes":{"data":{"attributes":{"_meta_allow_oob":{"category":"General","default":false,"desc":"Bypass out-of-bounds validation","metatype":"bool"},"_meta_data":{"category":"General","default":null,"desc":"Data descriptor attached to this memlet","metatype":"DataProperty"},"_meta_debuginfo":{"category":"General","default":{"end_column":0,"end_line":0,"filename":null,"start_column":0,"start_line":0,"type":"DebugInfo"},"desc":"Line information to track source and generated code","metatype":"DebugInfo"},"_meta_dynamic":{"category":"General","default":false,"desc":"Is the number of elements moved determined at runtime (e.g., data dependent)","metatype":"Property"},"_meta_other_subset":{"category":"General","default":null,"desc":"Subset of elements after reindexing to the data not attached to this edge (e.g., for offsets and reshaping).","metatype":"SubsetProperty"},"_meta_subset":{"category":"General","default":null,"desc":"Subset of elements to move from the data attached to this edge.","metatype":"SubsetProperty"},"_meta_volume":{"category":"General","default":0,"desc":"The exact number of elements moved using this memlet, or the maximum number if dynamic=True (with 0 as unbounded)","metatype":"SymbolicProperty"},"_meta_wcr":{"category":"General","default":null,"desc":"If set, defines a write-conflict resolution lambda function. The syntax of the lambda function receives two elements: `current` value and `new` value, and returns the value after resolution","metatype":"LambdaProperty"},"_meta_wcr_nonatomic":{"category":"General","default":false,"desc":"If True, always generates non-conflicting (non-atomic) writes in resulting code","metatype":"bool"},"allow_oob":false,"data":"Y","debuginfo":null,"dst_subset":{"ranges":[{"end":"N/2 + ceiling(N/2) - 1","start":"N/2","step":"1","tile":"1"}],"type":"Range"},"dynamic":false,"num_accesses":"ceiling(N/2)","other_subset":null,"src_subset":null,"subset":{"ranges":[{"end":"N/2 + ceiling(N/2) - 1","start":"N/2","step":"1","tile":"1"}],"type":"Range"},"volume":"ceiling(N/2)","wcr":null,"wcr_nonatomic":false},"type":"Memlet"}},"dst":"3","dst_connector":null,"src":"15","src_connector":null,"type":"MultiConnectorEdge"},{"attributes":{"data":{"attributes":{"_meta_allow_oob":{"category":"General","default":false,"desc":"Bypass out-of-bounds validation","metatype":"bool"},"_meta_data":{"category":"General","default":null,"desc":"Data descriptor attached to this memlet","metatype":"DataProperty"},"_meta_debuginfo":{"category":"General","default":{"end_column":0,"end_line":0,"filename":null,"start_column":0,"start_line":0,"type":"DebugInfo"},"desc":"Line information to track source and generated code","metatype":"DebugInfo"},"_meta_dynamic":{"category":"General","default":false,"desc":"Is the number of elements moved determined at runtime (e.g., data dependent)","metatype":"Property"},"_meta_other_subset":{"category":"General","default":null,"desc":"Subset of elements after reindexing to the data not attached to this edge (e.g., for offsets and reshaping).","metatype":"SubsetProperty"},"_meta_subset":{"category":"General","default":null,"desc":"Subset of elements to move from the data attached to this edge.","metatype":"SubsetProperty"},"_meta_volume":{"category":"General","default":0,"desc":"The exact number of elements moved using this memlet, or the maximum number if dynamic=True (with 0 as unbounded)","metatype":"SymbolicProperty"},"_meta_wcr":{"category":"General","default":null,"desc":"If set, defines a write-conflict resolution lambda function. The syntax of the lambda function receives two elements: `current` value and `new` value, and returns the value after resolution","metatype":"LambdaProperty"},"_meta_wcr_nonatomic":{"category":"General","default":false,"desc":"If True, always generates non-conflicting (non-atomic) writes in resulting code","metatype":"bool"},"allow_oob":false,"data":"A","debuginfo":null,"dst_subset":null,"dynamic":false,"num_accesses":"ceiling(N/2)","other_subset":null,"src_subset":{"ranges":[{"end":"0","start":"0","step":"1","tile":"1"}],"type":"Range"},"subset":{"ranges":[{"end":"0","start":"0","step":"1","tile":"1"}],"type":"Range"},"volume":"ceiling(N/2)","wcr":null,"wcr_nonatomic":false},"type":"Memlet"}},"dst":"6","dst_connector":"IN_A","src":"2","src_connector":null,"type":"MultiConnectorEdge"},{"attributes":{"data":{"attributes":{"_meta_allow_oob":{"category":"General","default":false,"desc":"Bypass out-of-bounds validation","metatype":"bool"},"_meta_data":{"category":"General","default":null,"desc":"Data descriptor attached to this memlet","metatype":"DataProperty"},"_meta_debuginfo":{"category":"General","default":{"end_column":0,"end_line":0,"filename":null,"start_column":0,"start_line":0,"type":"DebugInfo"},"desc":"Line information to track source and generated code","metatype":"DebugInfo"},"_meta_dynamic":{"category":"General","default":false,"desc":"Is the number of elements moved determined at runtime (e.g., data dependent)","metatype":"Property"},"_meta_other_subset":{"category":"General","default":null,"desc":"Subset of elements after reindexing to the data not attached to this edge (e.g., for offsets and reshaping).","metatype":"SubsetProperty"},"_meta_subset":{"category":"General","default":null,"desc":"Subset of elements to move from the data attached to this edge.","metatype":"SubsetProperty"},"_meta_volume":{"category":"General","default":0,"desc":"The exact number of elements moved using this memlet, or the maximum number if dynamic=True (with 0 as unbounded)","metatype":"SymbolicProperty"},"_meta_wcr":{"category":"General","default":null,"desc":"If set, defines a write-conflict resolution lambda function. The syntax of the lambda function receives two elements: `current` value and `new` value, and returns the value after resolution","metatype":"LambdaProperty"},"_meta_wcr_nonatomic":{"category":"General","default":false,"desc":"If True, always generates non-conflicting (non-atomic) writes in resulting code","metatype":"bool"},"allow_oob":false,"data":"A","debuginfo":null,"dst_subset":null,"dynamic":false,"num_accesses":"ceiling(N/2)","other_subset":null,"src_subset":{"ranges":[{"end":"0","start":"0","step":"1","tile":"1"}],"type":"Range"},"subset":{"ranges":[{"end":"0","start":"0","step":"1","tile":"1"}],"type":"Range"},"volume":"ceiling(N/2)","wcr":null,"wcr_nonatomic":false},"type":"Memlet"}},"dst":"12","dst_connector":"IN_A","src":"2","src_connector":null,"type":"MultiConnectorEdge"},{"attributes":{"data":{"attributes":{"_meta_allow_oob":{"category":"General","default":false,"desc":"Bypass out-of-bounds validation","metatype":"bool"},"_meta_data":{"category":"General","default":null,"desc":"Data descriptor attached to this memlet","metatype":"DataProperty"},"_meta_debuginfo":{"category":"General","default":{"end_column":0,"end_line":0,"filename":null,"start_column":0,"start_line":0,"type":"DebugInfo"},"desc":"Line information to track source and generated code","metatype":"DebugInfo"},"_meta_dynamic":{"category":"General","default":false,"desc":"Is the number of elements moved determined at runtime (e.g., data dependent)","metatype":"Property"},"_meta_other_subset":{"category":"General","default":null,"desc":"Subset of elements after reindexing to the data not attached to this edge (e.g., for offsets and reshaping).","metatype":"SubsetProperty"},"_meta_subset":{"category":"General","default":null,"desc":"Subset of elements to move from the data attached to this edge.","metatype":"SubsetProperty"},"_meta_volume":{"category":"General","default":0,"desc":"The exact number of elements moved using this memlet, or the maximum number if dynamic=True (with 0 as unbounded)","metatype":"SymbolicProperty"},"_meta_wcr":{"category":"General","default":null,"desc":"If set, defines a write-conflict resolution lambda function. The syntax of the lambda function receives two elements: `current` value and `new` value, and returns the value after resolution","metatype":"LambdaProperty"},"_meta_wcr_nonatomic":{"category":"General","default":false,"desc":"If True, always generates non-conflicting (non-atomic) writes in resulting code","metatype":"bool"},"allow_oob":false,"data":"nested_slice_X_8_gpu_X","debuginfo":null,"dst_subset":null,"dynamic":false,"num_accesses":"ceiling(N/2)","other_subset":null,"src_subset":{"ranges":[{"end":"N/2 - 1","start":"0","step":"1","tile":"1"}],"type":"Range"},"subset":{"ranges":[{"end":"N/2 - 1","start":"0","step":"1","tile":"1"}],"type":"Range"},"volume":"ceiling(N/2)","wcr":null,"wcr_nonatomic":false},"type":"Memlet"}},"dst":"6","dst_connector":"IN___tmp0","src":"4","src_connector":null,"type":"MultiConnectorEdge"},{"attributes":{"data":{"attributes":{"_meta_allow_oob":{"category":"General","default":false,"desc":"Bypass out-of-bounds validation","metatype":"bool"},"_meta_data":{"category":"General","default":null,"desc":"Data descriptor attached to this memlet","metatype":"DataProperty"},"_meta_debuginfo":{"category":"General","default":{"end_column":0,"end_line":0,"filename":null,"start_column":0,"start_line":0,"type":"DebugInfo"},"desc":"Line information to track source and generated code","metatype":"DebugInfo"},"_meta_dynamic":{"category":"General","default":false,"desc":"Is the number of elements moved determined at runtime (e.g., data dependent)","metatype":"Property"},"_meta_other_subset":{"category":"General","default":null,"desc":"Subset of elements after reindexing to the data not attached to this edge (e.g., for offsets and reshaping).","metatype":"SubsetProperty"},"_meta_subset":{"category":"General","default":null,"desc":"Subset of elements to move from the data attached to this edge.","metatype":"SubsetProperty"},"_meta_volume":{"category":"General","default":0,"desc":"The exact number of elements moved using this memlet, or the maximum number if dynamic=True (with 0 as unbounded)","metatype":"SymbolicProperty"},"_meta_wcr":{"category":"General","default":null,"desc":"If set, defines a write-conflict resolution lambda function. The syntax of the lambda function receives two elements: `current` value and `new` value, and returns the value after resolution","metatype":"LambdaProperty"},"_meta_wcr_nonatomic":{"category":"General","default":false,"desc":"If True, always generates non-conflicting (non-atomic) writes in resulting code","metatype":"bool"},"allow_oob":false,"data":"nested_slice_X_8_gpu_Y","debuginfo":null,"dst_subset":null,"dynamic":false,"num_accesses":"ceiling(N/2)","other_subset":null,"src_subset":{"ranges":[{"end":"N/2 - 1","start":"0","step":"1","tile":"1"}],"type":"Range"},"subset":{"ranges":[{"end":"N/2 - 1","start":"0","step":"1","tile":"1"}],"type":"Range"},"volume":"ceiling(N/2)","wcr":null,"wcr_nonatomic":false},"type":"Memlet"}},"dst":"6","dst_connector":"IN___tmp1","src":"5","src_connector":null,"type":"MultiConnectorEdge"},{"attributes":{"data":{"attributes":{"_meta_allow_oob":{"category":"General","default":false,"desc":"Bypass out-of-bounds validation","metatype":"bool"},"_meta_data":{"category":"General","default":null,"desc":"Data descriptor attached to this memlet","metatype":"DataProperty"},"_meta_debuginfo":{"category":"General","default":{"end_column":0,"end_line":0,"filename":null,"start_column":0,"start_line":0,"type":"DebugInfo"},"desc":"Line information to track source and generated code","metatype":"DebugInfo"},"_meta_dynamic":{"category":"General","default":false,"desc":"Is the number of elements moved determined at runtime (e.g., data dependent)","metatype":"Property"},"_meta_other_subset":{"category":"General","default":null,"desc":"Subset of elements after reindexing to the data not attached to this edge (e.g., for offsets and reshaping).","metatype":"SubsetProperty"},"_meta_subset":{"category":"General","default":null,"desc":"Subset of elements to move from the data attached to this edge.","metatype":"SubsetProperty"},"_meta_volume":{"category":"General","default":0,"desc":"The exact number of elements moved using this memlet, or the maximum number if dynamic=True (with 0 as unbounded)","metatype":"SymbolicProperty"},"_meta_wcr":{"category":"General","default":null,"desc":"If set, defines a write-conflict resolution lambda function. The syntax of the lambda function receives two elements: `current` value and `new` value, and returns the value after resolution","metatype":"LambdaProperty"},"_meta_wcr_nonatomic":{"category":"General","default":false,"desc":"If True, always generates non-conflicting (non-atomic) writes in resulting code","metatype":"bool"},"allow_oob":false,"data":"nested_slice_X_8_gpu_X_0","debuginfo":null,"dst_subset":null,"dynamic":false,"num_accesses":"ceiling(N/2)","other_subset":null,"src_subset":{"ranges":[{"end":"N/2 - 1","start":"0","step":"1","tile":"1"}],"type":"Range"},"subset":{"ranges":[{"end":"N/2 - 1","start":"0","step":"1","tile":"1"}],"type":"Range"},"volume":"ceiling(N/2)","wcr":null,"wcr_nonatomic":false},"type":"Memlet"}},"dst":"12","dst_connector":"IN___tmp2","src":"10","src_connector":null,"type":"MultiConnectorEdge"},{"attributes":{"data":{"attributes":{"_meta_allow_oob":{"category":"General","default":false,"desc":"Bypass out-of-bounds validation","metatype":"bool"},"_meta_data":{"category":"General","default":null,"desc":"Data descriptor attached to this memlet","metatype":"DataProperty"},"_meta_debuginfo":{"category":"General","default":{"end_column":0,"end_line":0,"filename":null,"start_column":0,"start_line":0,"type":"DebugInfo"},"desc":"Line information to track source and generated code","metatype":"DebugInfo"},"_meta_dynamic":{"category":"General","default":false,"desc":"Is the number of elements moved determined at runtime (e.g., data dependent)","metatype":"Property"},"_meta_other_subset":{"category":"General","default":null,"desc":"Subset of elements after reindexing to the data not attached to this edge (e.g., for offsets and reshaping).","metatype":"SubsetProperty"},"_meta_subset":{"category":"General","default":null,"desc":"Subset of elements to move from the data attached to this edge.","metatype":"SubsetProperty"},"_meta_volume":{"category":"General","default":0,"desc":"The exact number of elements moved using this memlet, or the maximum number if dynamic=True (with 0 as unbounded)","metatype":"SymbolicProperty"},"_meta_wcr":{"category":"General","default":null,"desc":"If set, defines a write-conflict resolution lambda function. The syntax of the lambda function receives two elements: `current` value and `new` value, and returns the value after resolution","metatype":"LambdaProperty"},"_meta_wcr_nonatomic":{"category":"General","default":false,"desc":"If True, always generates non-conflicting (non-atomic) writes in resulting code","metatype":"bool"},"allow_oob":false,"data":"nested_slice_X_8_gpu_Y_0","debuginfo":null,"dst_subset":null,"dynamic":false,"num_accesses":"ceiling(N/2)","other_subset":null,"src_subset":{"ranges":[{"end":"N/2 - 1","start":"0","step":"1","tile":"1"}],"type":"Range"},"subset":{"ranges":[{"end":"N/2 - 1","start":"0","step":"1","tile":"1"}],"type":"Range"},"volume":"ceiling(N/2)","wcr":null,"wcr_nonatomic":false},"type":"Memlet"}},"dst":"12","dst_connector":"IN___tmp3","src":"11","src_connector":null,"type":"MultiConnectorEdge"},{"attributes":{"data":{"attributes":{"_meta_allow_oob":{"category":"General","default":false,"desc":"Bypass out-of-bounds validation","metatype":"bool"},"_meta_data":{"category":"General","default":null,"desc":"Data descriptor attached to this memlet","metatype":"DataProperty"},"_meta_debuginfo":{"category":"General","default":{"end_column":0,"end_line":0,"filename":null,"start_column":0,"start_line":0,"type":"DebugInfo"},"desc":"Line information to track source and generated code","metatype":"DebugInfo"},"_meta_dynamic":{"category":"General","default":false,"desc":"Is the number of elements moved determined at runtime (e.g., data dependent)","metatype":"Property"},"_meta_other_subset":{"category":"General","default":null,"desc":"Subset of elements after reindexing to the data not attached to this edge (e.g., for offsets and reshaping).","metatype":"SubsetProperty"},"_meta_subset":{"category":"General","default":null,"desc":"Subset of elements to move from the data attached to this edge.","metatype":"SubsetProperty"},"_meta_volume":{"category":"General","default":0,"desc":"The exact number of elements moved using this memlet, or the maximum number if dynamic=True (with 0 as unbounded)","metatype":"SymbolicProperty"},"_meta_wcr":{"category":"General","default":null,"desc":"If set, defines a write-conflict resolution lambda function. The syntax of the lambda function receives two elements: `current` value and `new` value, and returns the value after resolution","metatype":"LambdaProperty"},"_meta_wcr_nonatomic":{"category":"General","default":false,"desc":"If True, always generates non-conflicting (non-atomic) writes in resulting code","metatype":"bool"},"allow_oob":false,"data":"A","debuginfo":null,"dst_subset":null,"dynamic":false,"num_accesses":"1","other_subset":null,"src_subset":{"ranges":[{"end":"0","start":"0","step":"1","tile":"1"}],"type":"Range"},"subset":{"ranges":[{"end":"0","start":"0","step":"1","tile":"1"}],"type":"Range"},"volume":"1","wcr":null,"wcr_nonatomic":false},"type":"Memlet"}},"dst":"8","dst_connector":"in_A1","src":"6","src_connector":"OUT_A","type":"MultiConnectorEdge"},{"attributes":{"data":{"attributes":{"_meta_allow_oob":{"category":"General","default":false,"desc":"Bypass out-of-bounds validation","metatype":"bool"},"_meta_data":{"category":"General","default":null,"desc":"Data descriptor attached to this memlet","metatype":"DataProperty"},"_meta_debuginfo":{"category":"General","default":{"end_column":0,"end_line":0,"filename":null,"start_column":0,"start_line":0,"type":"DebugInfo"},"desc":"Line information to track source and generated code","metatype":"DebugInfo"},"_meta_dynamic":{"category":"General","default":false,"desc":"Is the number of elements moved determined at runtime (e.g., data dependent)","metatype":"Property"},"_meta_other_subset":{"category":"General","default":null,"desc":"Subset of elements after reindexing to the data not attached to this edge (e.g., for offsets and reshaping).","metatype":"SubsetProperty"},"_meta_subset":{"category":"General","default":null,"desc":"Subset of elements to move from the data attached to this edge.","metatype":"SubsetProperty"},"_meta_volume":{"category":"General","default":0,"desc":"The exact number of elements moved using this memlet, or the maximum number if dynamic=True (with 0 as unbounded)","metatype":"SymbolicProperty"},"_meta_wcr":{"category":"General","default":null,"desc":"If set, defines a write-conflict resolution lambda function. The syntax of the lambda function receives two elements: `current` value and `new` value, and returns the value after resolution","metatype":"LambdaProperty"},"_meta_wcr_nonatomic":{"category":"General","default":false,"desc":"If True, always generates non-conflicting (non-atomic) writes in resulting code","metatype":"bool"},"allow_oob":false,"data":"A","debuginfo":null,"dst_subset":null,"dynamic":false,"num_accesses":"1","other_subset":null,"src_subset":{"ranges":[{"end":"0","start":"0","step":"1","tile":"1"}],"type":"Range"},"subset":{"ranges":[{"end":"0","start":"0","step":"1","tile":"1"}],"type":"Range"},"volume":"1","wcr":null,"wcr_nonatomic":false},"type":"Memlet"}},"dst":"14","dst_connector":"in_A2","src":"12","src_connector":"OUT_A","type":"MultiConnectorEdge"},{"attributes":{"data":{"attributes":{"_meta_allow_oob":{"category":"General","default":false,"desc":"Bypass out-of-bounds validation","metatype":"bool"},"_meta_data":{"category":"General","default":null,"desc":"Data descriptor attached to this memlet","metatype":"DataProperty"},"_meta_debuginfo":{"category":"General","default":{"end_column":0,"end_line":0,"filename":null,"start_column":0,"start_line":0,"type":"DebugInfo"},"desc":"Line information to track source and generated code","metatype":"DebugInfo"},"_meta_dynamic":{"category":"General","default":false,"desc":"Is the number of elements moved determined at runtime (e.g., data dependent)","metatype":"Property"},"_meta_other_subset":{"category":"General","default":null,"desc":"Subset of elements after reindexing to the data not attached to this edge (e.g., for offsets and reshaping).","metatype":"SubsetProperty"},"_meta_subset":{"category":"General","default":null,"desc":"Subset of elements to move from the data attached to this edge.","metatype":"SubsetProperty"},"_meta_volume":{"category":"General","default":0,"desc":"The exact number of elements moved using this memlet, or the maximum number if dynamic=True (with 0 as unbounded)","metatype":"SymbolicProperty"},"_meta_wcr":{"category":"General","default":null,"desc":"If set, defines a write-conflict resolution lambda function. The syntax of the lambda function receives two elements: `current` value and `new` value, and returns the value after resolution","metatype":"LambdaProperty"},"_meta_wcr_nonatomic":{"category":"General","default":false,"desc":"If True, always generates non-conflicting (non-atomic) writes in resulting code","metatype":"bool"},"allow_oob":false,"data":"nested_slice_X_8_gpu_Y","debuginfo":null,"dst_subset":{"ranges":[{"end":"N/2 - 1","start":"0","step":"1","tile":"1"}],"type":"Range"},"dynamic":false,"num_accesses":"ceiling(N/2)","other_subset":null,"src_subset":null,"subset":{"ranges":[{"end":"N/2 - 1","start":"0","step":"1","tile":"1"}],"type":"Range"},"volume":"ceiling(N/2)","wcr":null,"wcr_nonatomic":false},"type":"Memlet"}},"dst":"9","dst_connector":null,"src":"7","src_connector":"OUT_Y","type":"MultiConnectorEdge"},{"attributes":{"data":{"attributes":{"_meta_allow_oob":{"category":"General","default":false,"desc":"Bypass out-of-bounds validation","metatype":"bool"},"_meta_data":{"category":"General","default":null,"desc":"Data descriptor attached to this memlet","metatype":"DataProperty"},"_meta_debuginfo":{"category":"General","default":{"end_column":0,"end_line":0,"filename":null,"start_column":0,"start_line":0,"type":"DebugInfo"},"desc":"Line information to track source and generated code","metatype":"DebugInfo"},"_meta_dynamic":{"category":"General","default":false,"desc":"Is the number of elements moved determined at runtime (e.g., data dependent)","metatype":"Property"},"_meta_other_subset":{"category":"General","default":null,"desc":"Subset of elements after reindexing to the data not attached to this edge (e.g., for offsets and reshaping).","metatype":"SubsetProperty"},"_meta_subset":{"category":"General","default":null,"desc":"Subset of elements to move from the data attached to this edge.","metatype":"SubsetProperty"},"_meta_volume":{"category":"General","default":0,"desc":"The exact number of elements moved using this memlet, or the maximum number if dynamic=True (with 0 as unbounded)","metatype":"SymbolicProperty"},"_meta_wcr":{"category":"General","default":null,"desc":"If set, defines a write-conflict resolution lambda function. The syntax of the lambda function receives two elements: `current` value and `new` value, and returns the value after resolution","metatype":"LambdaProperty"},"_meta_wcr_nonatomic":{"category":"General","default":false,"desc":"If True, always generates non-conflicting (non-atomic) writes in resulting code","metatype":"bool"},"allow_oob":false,"data":"nested_slice_X_8_gpu_Y_0","debuginfo":null,"dst_subset":{"ranges":[{"end":"N/2 - 1","start":"0","step":"1","tile":"1"}],"type":"Range"},"dynamic":false,"num_accesses":"ceiling(N/2)","other_subset":null,"src_subset":null,"subset":{"ranges":[{"end":"N/2 - 1","start":"0","step":"1","tile":"1"}],"type":"Range"},"volume":"ceiling(N/2)","wcr":null,"wcr_nonatomic":false},"type":"Memlet"}},"dst":"15","dst_connector":null,"src":"13","src_connector":"OUT_Y","type":"MultiConnectorEdge"},{"attributes":{"data":{"attributes":{"_meta_allow_oob":{"category":"General","default":false,"desc":"Bypass out-of-bounds validation","metatype":"bool"},"_meta_data":{"category":"General","default":null,"desc":"Data descriptor attached to this memlet","metatype":"DataProperty"},"_meta_debuginfo":{"category":"General","default":{"end_column":0,"end_line":0,"filename":null,"start_column":0,"start_line":0,"type":"DebugInfo"},"desc":"Line information to track source and generated code","metatype":"DebugInfo"},"_meta_dynamic":{"category":"General","default":false,"desc":"Is the number of elements moved determined at runtime (e.g., data dependent)","metatype":"Property"},"_meta_other_subset":{"category":"General","default":null,"desc":"Subset of elements after reindexing to the data not attached to this edge (e.g., for offsets and reshaping).","metatype":"SubsetProperty"},"_meta_subset":{"category":"General","default":null,"desc":"Subset of elements to move from the data attached to this edge.","metatype":"SubsetProperty"},"_meta_volume":{"category":"General","default":0,"desc":"The exact number of elements moved using this memlet, or the maximum number if dynamic=True (with 0 as unbounded)","metatype":"SymbolicProperty"},"_meta_wcr":{"category":"General","default":null,"desc":"If set, defines a write-conflict resolution lambda function. The syntax of the lambda function receives two elements: `current` value and `new` value, and returns the value after resolution","metatype":"LambdaProperty"},"_meta_wcr_nonatomic":{"category":"General","default":false,"desc":"If True, always generates non-conflicting (non-atomic) writes in resulting code","metatype":"bool"},"allow_oob":false,"data":"nested_slice_X_8_gpu_X","debuginfo":null,"dst_subset":null,"dynamic":false,"num_accesses":"1","other_subset":null,"src_subset":{"ranges":[{"end":"i","start":"i","step":"1","tile":"1"}],"type":"Range"},"subset":{"ranges":[{"end":"i","start":"i","step":"1","tile":"1"}],"type":"Range"},"volume":"1","wcr":null,"wcr_nonatomic":false},"type":"Memlet"}},"dst":"8","dst_connector":"in_X1","src":"6","src_connector":"OUT___tmp0","type":"MultiConnectorEdge"},{"attributes":{"data":{"attributes":{"_meta_allow_oob":{"category":"General","default":false,"desc":"Bypass out-of-bounds validation","metatype":"bool"},"_meta_data":{"category":"General","default":null,"desc":"Data descriptor attached to this memlet","metatype":"DataProperty"},"_meta_debuginfo":{"category":"General","default":{"end_column":0,"end_line":0,"filename":null,"start_column":0,"start_line":0,"type":"DebugInfo"},"desc":"Line information to track source and generated code","metatype":"DebugInfo"},"_meta_dynamic":{"category":"General","default":false,"desc":"Is the number of elements moved determined at runtime (e.g., data dependent)","metatype":"Property"},"_meta_other_subset":{"category":"General","default":null,"desc":"Subset of elements after reindexing to the data not attached to this edge (e.g., for offsets and reshaping).","metatype":"SubsetProperty"},"_meta_subset":{"category":"General","default":null,"desc":"Subset of elements to move from the data attached to this edge.","metatype":"SubsetProperty"},"_meta_volume":{"category":"General","default":0,"desc":"The exact number of elements moved using this memlet, or the maximum number if dynamic=True (with 0 as unbounded)","metatype":"SymbolicProperty"},"_meta_wcr":{"category":"General","default":null,"desc":"If set, defines a write-conflict resolution lambda function. The syntax of the lambda function receives two elements: `current` value and `new` value, and returns the value after resolution","metatype":"LambdaProperty"},"_meta_wcr_nonatomic":{"category":"General","default":false,"desc":"If True, always generates non-conflicting (non-atomic) writes in resulting code","metatype":"bool"},"allow_oob":false,"data":"nested_slice_X_8_gpu_Y","debuginfo":null,"dst_subset":null,"dynamic":false,"num_accesses":"1","other_subset":null,"src_subset":{"ranges":[{"end":"i","start":"i","step":"1","tile":"1"}],"type":"Range"},"subset":{"ranges":[{"end":"i","start":"i","step":"1","tile":"1"}],"type":"Range"},"volume":"1","wcr":null,"wcr_nonatomic":false},"type":"Memlet"}},"dst":"8","dst_connector":"in_Y1","src":"6","src_connector":"OUT___tmp1","type":"MultiConnectorEdge"},{"attributes":{"data":{"attributes":{"_meta_allow_oob":{"category":"General","default":false,"desc":"Bypass out-of-bounds validation","metatype":"bool"},"_meta_data":{"category":"General","default":null,"desc":"Data descriptor attached to this memlet","metatype":"DataProperty"},"_meta_debuginfo":{"category":"General","default":{"end_column":0,"end_line":0,"filename":null,"start_column":0,"start_line":0,"type":"DebugInfo"},"desc":"Line information to track source and generated code","metatype":"DebugInfo"},"_meta_dynamic":{"category":"General","default":false,"desc":"Is the number of elements moved determined at runtime (e.g., data dependent)","metatype":"Property"},"_meta_other_subset":{"category":"General","default":null,"desc":"Subset of elements after reindexing to the data not attached to this edge (e.g., for offsets and reshaping).","metatype":"SubsetProperty"},"_meta_subset":{"category":"General","default":null,"desc":"Subset of elements to move from the data attached to this edge.","metatype":"SubsetProperty"},"_meta_volume":{"category":"General","default":0,"desc":"The exact number of elements moved using this memlet, or the maximum number if dynamic=True (with 0 as unbounded)","metatype":"SymbolicProperty"},"_meta_wcr":{"category":"General","default":null,"desc":"If set, defines a write-conflict resolution lambda function. The syntax of the lambda function receives two elements: `current` value and `new` value, and returns the value after resolution","metatype":"LambdaProperty"},"_meta_wcr_nonatomic":{"category":"General","default":false,"desc":"If True, always generates non-conflicting (non-atomic) writes in resulting code","metatype":"bool"},"allow_oob":false,"data":"nested_slice_X_8_gpu_X_0","debuginfo":null,"dst_subset":null,"dynamic":false,"num_accesses":"1","other_subset":null,"src_subset":{"ranges":[{"end":"i","start":"i","step":"1","tile":"1"}],"type":"Range"},"subset":{"ranges":[{"end":"i","start":"i","step":"1","tile":"1"}],"type":"Range"},"volume":"1","wcr":null,"wcr_nonatomic":false},"type":"Memlet"}},"dst":"14","dst_connector":"in_X2","src":"12","src_connector":"OUT___tmp2","type":"MultiConnectorEdge"},{"attributes":{"data":{"attributes":{"_meta_allow_oob":{"category":"General","default":false,"desc":"Bypass out-of-bounds validation","metatype":"bool"},"_meta_data":{"category":"General","default":null,"desc":"Data descriptor attached to this memlet","metatype":"DataProperty"},"_meta_debuginfo":{"category":"General","default":{"end_column":0,"end_line":0,"filename":null,"start_column":0,"start_line":0,"type":"DebugInfo"},"desc":"Line information to track source and generated code","metatype":"DebugInfo"},"_meta_dynamic":{"category":"General","default":false,"desc":"Is the number of elements moved determined at runtime (e.g., data dependent)","metatype":"Property"},"_meta_other_subset":{"category":"General","default":null,"desc":"Subset of elements after reindexing to the data not attached to this edge (e.g., for offsets and reshaping).","metatype":"SubsetProperty"},"_meta_subset":{"category":"General","default":null,"desc":"Subset of elements to move from the data attached to this edge.","metatype":"SubsetProperty"},"_meta_volume":{"category":"General","default":0,"desc":"The exact number of elements moved using this memlet, or the maximum number if dynamic=True (with 0 as unbounded)","metatype":"SymbolicProperty"},"_meta_wcr":{"category":"General","default":null,"desc":"If set, defines a write-conflict resolution lambda function. The syntax of the lambda function receives two elements: `current` value and `new` value, and returns the value after resolution","metatype":"LambdaProperty"},"_meta_wcr_nonatomic":{"category":"General","default":false,"desc":"If True, always generates non-conflicting (non-atomic) writes in resulting code","metatype":"bool"},"allow_oob":false,"data":"nested_slice_X_8_gpu_Y_0","debuginfo":null,"dst_subset":null,"dynamic":false,"num_accesses":"1","other_subset":null,"src_subset":{"ranges":[{"end":"i","start":"i","step":"1","tile":"1"}],"type":"Range"},"subset":{"ranges":[{"end":"i","start":"i","step":"1","tile":"1"}],"type":"Range"},"volume":"1","wcr":null,"wcr_nonatomic":false},"type":"Memlet"}},"dst":"14","dst_connector":"in_Y2","src":"12","src_connector":"OUT___tmp3","type":"MultiConnectorEdge"},{"attributes":{"data":{"attributes":{"_meta_allow_oob":{"category":"General","default":false,"desc":"Bypass out-of-bounds validation","metatype":"bool"},"_meta_data":{"category":"General","default":null,"desc":"Data descriptor attached to this memlet","metatype":"DataProperty"},"_meta_debuginfo":{"category":"General","default":{"end_column":0,"end_line":0,"filename":null,"start_column":0,"start_line":0,"type":"DebugInfo"},"desc":"Line information to track source and generated code","metatype":"DebugInfo"},"_meta_dynamic":{"category":"General","default":false,"desc":"Is the number of elements moved determined at runtime (e.g., data dependent)","metatype":"Property"},"_meta_other_subset":{"category":"General","default":null,"desc":"Subset of elements after reindexing to the data not attached to this edge (e.g., for offsets and reshaping).","metatype":"SubsetProperty"},"_meta_subset":{"category":"General","default":null,"desc":"Subset of elements to move from the data attached to this edge.","metatype":"SubsetProperty"},"_meta_volume":{"category":"General","default":0,"desc":"The exact number of elements moved using this memlet, or the maximum number if dynamic=True (with 0 as unbounded)","metatype":"SymbolicProperty"},"_meta_wcr":{"category":"General","default":null,"desc":"If set, defines a write-conflict resolution lambda function. The syntax of the lambda function receives two elements: `current` value and `new` value, and returns the value after resolution","metatype":"LambdaProperty"},"_meta_wcr_nonatomic":{"category":"General","default":false,"desc":"If True, always generates non-conflicting (non-atomic) writes in resulting code","metatype":"bool"},"allow_oob":false,"data":"nested_slice_X_8_gpu_Y","debuginfo":null,"dst_subset":{"ranges":[{"end":"i","start":"i","step":"1","tile":"1"}],"type":"Range"},"dynamic":false,"num_accesses":"1","other_subset":null,"src_subset":null,"subset":{"ranges":[{"end":"i","start":"i","step":"1","tile":"1"}],"type":"Range"},"volume":"1","wcr":null,"wcr_nonatomic":false},"type":"Memlet"}},"dst":"7","dst_connector":"IN_Y","src":"8","src_connector":"out1","type":"MultiConnectorEdge"},{"attributes":{"data":{"attributes":{"_meta_allow_oob":{"category":"General","default":false,"desc":"Bypass out-of-bounds validation","metatype":"bool"},"_meta_data":{"category":"General","default":null,"desc":"Data descriptor attached to this memlet","metatype":"DataProperty"},"_meta_debuginfo":{"category":"General","default":{"end_column":0,"end_line":0,"filename":null,"start_column":0,"start_line":0,"type":"DebugInfo"},"desc":"Line information to track source and generated code","metatype":"DebugInfo"},"_meta_dynamic":{"category":"General","default":false,"desc":"Is the number of elements moved determined at runtime (e.g., data dependent)","metatype":"Property"},"_meta_other_subset":{"category":"General","default":null,"desc":"Subset of elements after reindexing to the data not attached to this edge (e.g., for offsets and reshaping).","metatype":"SubsetProperty"},"_meta_subset":{"category":"General","default":null,"desc":"Subset of elements to move from the data attached to this edge.","metatype":"SubsetProperty"},"_meta_volume":{"category":"General","default":0,"desc":"The exact number of elements moved using this memlet, or the maximum number if dynamic=True (with 0 as unbounded)","metatype":"SymbolicProperty"},"_meta_wcr":{"category":"General","default":null,"desc":"If set, defines a write-conflict resolution lambda function. The syntax of the lambda function receives two elements: `current` value and `new` value, and returns the value after resolution","metatype":"LambdaProperty"},"_meta_wcr_nonatomic":{"category":"General","default":false,"desc":"If True, always generates non-conflicting (non-atomic) writes in resulting code","metatype":"bool"},"allow_oob":false,"data":"nested_slice_X_8_gpu_Y_0","debuginfo":null,"dst_subset":{"ranges":[{"end":"i","start":"i","step":"1","tile":"1"}],"type":"Range"},"dynamic":false,"num_accesses":"1","other_subset":null,"src_subset":null,"subset":{"ranges":[{"end":"i","start":"i","step":"1","tile":"1"}],"type":"Range"},"volume":"1","wcr":null,"wcr_nonatomic":false},"type":"Memlet"}},"dst":"13","dst_connector":"IN_Y","src":"14","src_connector":"out2","type":"MultiConnectorEdge"}],"id":0,"label":"slice_X_8","nodes":[{"attributes":{"_meta_access":{"category":"General","default":"ReadWrite","desc":"Type of access to this array","metatype":"AccessType"},"_meta_data":{"category":"General","default":null,"desc":"Data (array, stream, scalar) to access","metatype":"DataProperty"},"_meta_debuginfo":{"category":"General","default":{"end_column":0,"end_line":0,"filename":null,"start_column":0,"start_line":0,"type":"DebugInfo"},"desc":"","metatype":"DebugInfo"},"_meta_in_connectors":{"category":"General","default":{},"desc":"A set of input connectors for this node.","metatype":"dict"},"_meta_out_connectors":{"category":"General","default":{},"desc":"A set of output connectors for this node.","metatype":"dict"},"_meta_setzero":{"category":"General","default":false,"desc":"Initialize to zero","metatype":"bool"},"access":"ReadWrite","data":"X","debuginfo":{"end_column":9,"end_line":8,"filename":"/var/folders/fh/hmjqvm896lq967r6bq0kfnjc0000gn/T/tmplp5hl0c4/fake.py","start_column":9,"start_line":8,"type":"DebugInfo"},"in_connectors":{},"out_connectors":{},"setzero":false},"id":0,"label":"X","scope_entry":null,"scope_exit":null,"type":"AccessNode"},{"attributes":{"_meta_access":{"category":"General","default":"ReadWrite","desc":"Type of access to this array","metatype":"AccessType"},"_meta_data":{"category":"General","default":null,"desc":"Data (array, stream, scalar) to access","metatype":"DataProperty"},"_meta_debuginfo":{"category":"General","default":{"end_column":0,"end_line":0,"filename":null,"start_column":0,"start_line":0,"type":"DebugInfo"},"desc":"","metatype":"DebugInfo"},"_meta_in_connectors":{"category":"General","default":{},"desc":"A set of input connectors for this node.","metatype":"dict"},"_meta_out_connectors":{"category":"General","default":{},"desc":"A set of output connectors for this node.","metatype":"dict"},"_meta_setzero":{"category":"General","default":false,"desc":"Initialize to zero","metatype":"bool"},"access":"ReadWrite","data":"Y","debuginfo":{"end_column":9,"end_line":9,"filename":"/var/folders/fh/hmjqvm896lq967r6bq0kfnjc0000gn/T/tmplp5hl0c4/fake.py","start_column":9,"start_line":9,"type":"DebugInfo"},"in_connectors":{},"out_connectors":{},"setzero":false},"id":1,"label":"Y","scope_entry":null,"scope_exit":null,"type":"AccessNode"},{"attributes":{"_meta_access":{"category":"General","default":"ReadWrite","desc":"Type of access to this array","metatype":"AccessType"},"_meta_data":{"category":"General","default":null,"desc":"Data (array, stream, scalar) to access","metatype":"DataProperty"},"_meta_debuginfo":{"category":"General","default":{"end_column":0,"end_line":0,"filename":null,"start_column":0,"start_line":0,"type":"DebugInfo"},"desc":"","metatype":"DebugInfo"},"_meta_in_connectors":{"category":"General","default":{},"desc":"A set of input connectors for this node.","metatype":"dict"},"_meta_out_connectors":{"category":"General","default":{},"desc":"A set of output connectors for this node.","metatype":"dict"},"_meta_setzero":{"category":"General","default":false,"desc":"Initialize to zero","metatype":"bool"},"access":"ReadWrite","data":"A","debuginfo":{"end_column":4,"end_line":15,"filename":"/var/folders/fh/hmjqvm896lq967r6bq0kfnjc0000gn/T/tmplp5hl0c4/fake.py","start_column":4,"start_line":15,"type":"DebugInfo"},"in_connectors":{},"out_connectors":{},"setzero":false},"id":2,"label":"A","scope_entry":null,"scope_exit":null,"type":"AccessNode"},{"attributes":{"_meta_access":{"category":"General","default":"ReadWrite","desc":"Type of access to this array","metatype":"AccessType"},"_meta_data":{"category":"General","default":null,"desc":"Data (array, stream, scalar) to access","metatype":"DataProperty"},"_meta_debuginfo":{"category":"General","default":{"end_column":0,"end_line":0,"filename":null,"start_column":0,"start_line":0,"type":"DebugInfo"},"desc":"","metatype":"DebugInfo"},"_meta_in_connectors":{"category":"General","default":{},"desc":"A set of input connectors for this node.","metatype":"dict"},"_meta_out_connectors":{"category":"General","default":{},"desc":"A set of output connectors for this node.","metatype":"dict"},"_meta_setzero":{"category":"General","default":false,"desc":"Initialize to zero","metatype":"bool"},"access":"WriteOnly","data":"Y","debuginfo":{"end_column":4,"end_line":15,"filename":"/var/folders/fh/hmjqvm896lq967r6bq0kfnjc0000gn/T/tmplp5hl0c4/fake.py","start_column":4,"start_line":15,"type":"DebugInfo"},"in_connectors":{},"out_connectors":{},"setzero":false},"id":3,"label":"Y","scope_entry":null,"scope_exit":null,"type":"AccessNode"},{"attributes":{"_meta_access":{"category":"General","default":"ReadWrite","desc":"Type of access to this array","metatype":"AccessType"},"_meta_data":{"category":"General","default":null,"desc":"Data (array, stream, scalar) to access","metatype":"DataProperty"},"_meta_debuginfo":{"category":"General","default":{"end_column":0,"end_line":0,"filename":null,"start_column":0,"start_line":0,"type":"DebugInfo"},"desc":"","metatype":"DebugInfo"},"_meta_in_connectors":{"category":"General","default":{},"desc":"A set of input connectors for this node.","metatype":"dict"},"_meta_out_connectors":{"category":"General","default":{},"desc":"A set of output connectors for this node.","metatype":"dict"},"_meta_setzero":{"category":"General","default":false,"desc":"Initialize to zero","metatype":"bool"},"access":"ReadWrite","data":"nested_slice_X_8_gpu_X","debuginfo":null,"in_connectors":{},"out_connectors":{},"setzero":false},"id":4,"label":"nested_slice_X_8_gpu_X","scope_entry":null,"scope_exit":null,"type":"AccessNode"},{"attributes":{"_meta_access":{"category":"General","default":"ReadWrite","desc":"Type of access to this array","metatype":"AccessType"},"_meta_data":{"category":"General","default":null,"desc":"Data (array, stream, scalar) to access","metatype":"DataProperty"},"_meta_debuginfo":{"category":"General","default":{"end_column":0,"end_line":0,"filename":null,"start_column":0,"start_line":0,"type":"DebugInfo"},"desc":"","metatype":"DebugInfo"},"_meta_in_connectors":{"category":"General","default":{},"desc":"A set of input connectors for this node.","metatype":"dict"},"_meta_out_connectors":{"category":"General","default":{},"desc":"A set of output connectors for this node.","metatype":"dict"},"_meta_setzero":{"category":"General","default":false,"desc":"Initialize to zero","metatype":"bool"},"access":"ReadWrite","data":"nested_slice_X_8_gpu_Y","debuginfo":null,"in_connectors":{},"out_connectors":{},"setzero":false},"id":5,"label":"nested_slice_X_8_gpu_Y","scope_entry":null,"scope_exit":null,"type":"AccessNode"},{"attributes":{"_meta_collapse":{"category":"General","default":1,"desc":"How many dimensions to collapse into the parallel range","indirected":true,"metatype":"int"},"_meta_debuginfo":{"category":"General","default":{"end_column":0,"end_line":0,"filename":null,"start_column":0,"start_line":0,"type":"DebugInfo"},"desc":"","indirected":true,"metatype":"DebugInfo"},"_meta_in_connectors":{"category":"General","default":{},"desc":"A set of input connectors for this node.","metatype":"dict"},"_meta_instrument":{"category":"General","default":"No_Instrumentation","desc":"Measure execution statistics with given method","indirected":true,"metatype":"InstrumentationType"},"_meta_is_collapsed":{"category":"General","default":false,"desc":"Show this node/scope/state as collapsed","indirected":true,"metatype":"bool"},"_meta_label":{"category":"General","default":"","desc":"Label of the map","indirected":true,"metatype":"str"},"_meta_out_connectors":{"category":"General","default":{},"desc":"A set of output connectors for this node.","metatype":"dict"},"_meta_params":{"category":"General","default":[],"desc":"Mapped parameters","indirected":true,"metatype":"list"},"_meta_range":{"category":"General","default":{"ranges":[],"type":"Range"},"desc":"Ranges of map parameters","indirected":true,"metatype":"Range"},"_meta_schedule":{"category":"General","default":"Default","desc":"Map schedule","indirected":true,"metatype":"ScheduleType"},"_meta_unroll":{"category":"General","default":false,"desc":"Map unrolling","indirected":true,"metatype":"bool"},"collapse":1,"debuginfo":{"end_column":4,"end_line":15,"filename":"/var/folders/fh/hmjqvm896lq967r6bq0kfnjc0000gn/T/tmplp5hl0c4/fake.py","start_column":4,"start_line":15,"type":"DebugInfo"},"in_connectors":{"IN_A":null,"IN___tmp0":null,"IN___tmp1":null},"instrument":"No_Instrumentation","is_collapsed":false,"label":"multiplication","out_connectors":{"OUT_A":null,"OUT___tmp0":null,"OUT___tmp1":null},"params":["i"],"range":{"ranges":[{"end":"N/2 - 1","start":"0","step":"1","tile":"1"}],"type":"Range"},"schedule":"GPU_Device","unroll":false},"id":6,"label":"multiplication[i=0:N/2]","scope_entry":null,"scope_exit":"7","type":"MapEntry"},{"attributes":{"_meta_in_connectors":{"category":"General","default":{},"desc":"A set of input connectors for this node.","metatype":"dict"},"_meta_out_connectors":{"category":"General","default":{},"desc":"A set of output connectors for this node.","metatype":"dict"},"in_connectors":{"IN_Y":null},"out_connectors":{"OUT_Y":null}},"id":7,"label":"multiplication[i=0:N/2]","scope_entry":"6","scope_exit":"7","type":"MapExit"},{"attributes":{"_meta_code":{"category":"General","default":{"language":"Python","string_data":""},"desc":"Tasklet code","metatype":"CodeBlock"},"_meta_debuginfo":{"category":"General","default":{"end_column":0,"end_line":0,"filename":null,"start_column":0,"start_line":0,"type":"DebugInfo"},"desc":"","metatype":"DebugInfo"},"_meta_environments":{"category":"General","default":[],"desc":"Environments required by CMake to build and run this code node.","metatype":"set"},"_meta_in_connectors":{"category":"General","default":{},"desc":"A set of input connectors for this node.","metatype":"dict"},"_meta_instrument":{"category":"General","default":"No_Instrumentation","desc":"Measure execution statistics with given method","metatype":"InstrumentationType"},"_meta_label":{"category":"General","default":"","desc":"Name of the CodeNode","metatype":"str"},"_meta_location":{"category":"General","default":{},"desc":"Full storage location identifier (e.g., rank, GPU ID)","metatype":"dict"},"_meta_out_connectors":{"category":"General","default":{},"desc":"A set of output connectors for this node.","metatype":"dict"},"code":{"language":"Python","string_data":"out1 = ((in_A1 * in_X1) + in_Y1)"},"debuginfo":{"end_column":8,"end_line":21,"filename":"/var/folders/fh/hmjqvm896lq967r6bq0kfnjc0000gn/T/tmplp5hl0c4/fake.py","start_column":4,"start_line":15,"type":"DebugInfo"},"environments":[],"in_connectors":{"in_A1":null,"in_X1":null,"in_Y1":null},"instrument":"No_Instrumentation","label":"multiplication","location":{"gpu":"0"},"out_connectors":{"out1":null}},"id":8,"label":"multiplication","scope_entry":"6","scope_exit":"7","type":"Tasklet"},{"attributes":{"_meta_access":{"category":"General","default":"ReadWrite","desc":"Type of access to this array","metatype":"AccessType"},"_meta_data":{"category":"General","default":null,"desc":"Data (array, stream, scalar) to access","metatype":"DataProperty"},"_meta_debuginfo":{"category":"General","default":{"end_column":0,"end_line":0,"filename":null,"start_column":0,"start_line":0,"type":"DebugInfo"},"desc":"","metatype":"DebugInfo"},"_meta_in_connectors":{"category":"General","default":{},"desc":"A set of input connectors for this node.","metatype":"dict"},"_meta_out_connectors":{"category":"General","default":{},"desc":"A set of output connectors for this node.","metatype":"dict"},"_meta_setzero":{"category":"General","default":false,"desc":"Initialize to zero","metatype":"bool"},"access":"ReadWrite","data":"nested_slice_X_8_gpu_Y","debuginfo":{"end_column":0,"end_line":208,"filename":"/Users/Thomas/Documents/eth/2020hs/thesis/dace/dace/transformation/helpers.py","start_column":0,"start_line":208,"type":"DebugInfo"},"in_connectors":{},"out_connectors":{},"setzero":false},"id":9,"label":"nested_slice_X_8_gpu_Y","scope_entry":null,"scope_exit":null,"type":"AccessNode"},{"attributes":{"_meta_access":{"category":"General","default":"ReadWrite","desc":"Type of access to this array","metatype":"AccessType"},"_meta_data":{"category":"General","default":null,"desc":"Data (array, stream, scalar) to access","metatype":"DataProperty"},"_meta_debuginfo":{"category":"General","default":{"end_column":0,"end_line":0,"filename":null,"start_column":0,"start_line":0,"type":"DebugInfo"},"desc":"","metatype":"DebugInfo"},"_meta_in_connectors":{"category":"General","default":{},"desc":"A set of input connectors for this node.","metatype":"dict"},"_meta_out_connectors":{"category":"General","default":{},"desc":"A set of output connectors for this node.","metatype":"dict"},"_meta_setzero":{"category":"General","default":false,"desc":"Initialize to zero","metatype":"bool"},"access":"ReadWrite","data":"nested_slice_X_8_gpu_X_0","debuginfo":null,"in_connectors":{},"out_connectors":{},"setzero":false},"id":10,"label":"nested_slice_X_8_gpu_X_0","scope_entry":null,"scope_exit":null,"type":"AccessNode"},{"attributes":{"_meta_access":{"category":"General","default":"ReadWrite","desc":"Type of access to this array","metatype":"AccessType"},"_meta_data":{"category":"General","default":null,"desc":"Data (array, stream, scalar) to access","metatype":"DataProperty"},"_meta_debuginfo":{"category":"General","default":{"end_column":0,"end_line":0,"filename":null,"start_column":0,"start_line":0,"type":"DebugInfo"},"desc":"","metatype":"DebugInfo"},"_meta_in_connectors":{"category":"General","default":{},"desc":"A set of input connectors for this node.","metatype":"dict"},"_meta_out_connectors":{"category":"General","default":{},"desc":"A set of output connectors for this node.","metatype":"dict"},"_meta_setzero":{"category":"General","default":false,"desc":"Initialize to zero","metatype":"bool"},"access":"ReadWrite","data":"nested_slice_X_8_gpu_Y_0","debuginfo":null,"in_connectors":{},"out_connectors":{},"setzero":false},"id":11,"label":"nested_slice_X_8_gpu_Y_0","scope_entry":null,"scope_exit":null,"type":"AccessNode"},{"attributes":{"_meta_collapse":{"category":"General","default":1,"desc":"How many dimensions to collapse into the parallel range","indirected":true,"metatype":"int"},"_meta_debuginfo":{"category":"General","default":{"end_column":0,"end_line":0,"filename":null,"start_column":0,"start_line":0,"type":"DebugInfo"},"desc":"","indirected":true,"metatype":"DebugInfo"},"_meta_in_connectors":{"category":"General","default":{},"desc":"A set of input connectors for this node.","metatype":"dict"},"_meta_instrument":{"category":"General","default":"No_Instrumentation","desc":"Measure execution statistics with given method","indirected":true,"metatype":"InstrumentationType"},"_meta_is_collapsed":{"category":"General","default":false,"desc":"Show this node/scope/state as collapsed","indirected":true,"metatype":"bool"},"_meta_label":{"category":"General","default":"","desc":"Label of the map","indirected":true,"metatype":"str"},"_meta_out_connectors":{"category":"General","default":{},"desc":"A set of output connectors for this node.","metatype":"dict"},"_meta_params":{"category":"General","default":[],"desc":"Mapped parameters","indirected":true,"metatype":"list"},"_meta_range":{"category":"General","default":{"ranges":[],"type":"Range"},"desc":"Ranges of map parameters","indirected":true,"metatype":"Range"},"_meta_schedule":{"category":"General","default":"Default","desc":"Map schedule","indirected":true,"metatype":"ScheduleType"},"_meta_unroll":{"category":"General","default":false,"desc":"Map unrolling","indirected":true,"metatype":"bool"},"collapse":1,"debuginfo":{"end_column":4,"end_line":24,"filename":"/var/folders/fh/hmjqvm896lq967r6bq0kfnjc0000gn/T/tmplp5hl0c4/fake.py","start_column":4,"start_line":24,"type":"DebugInfo"},"in_connectors":{"IN_A":null,"IN___tmp2":null,"IN___tmp3":null},"instrument":"No_Instrumentation","is_collapsed":false,"label":"multiplication","out_connectors":{"OUT_A":null,"OUT___tmp2":null,"OUT___tmp3":null},"params":["i"],"range":{"ranges":[{"end":"N/2 - 1","start":"0","step":"1","tile":"1"}],"type":"Range"},"schedule":"GPU_Device","unroll":false},"id":12,"label":"multiplication[i=0:N/2]","scope_entry":null,"scope_exit":"13","type":"MapEntry"},{"attributes":{"_meta_in_connectors":{"category":"General","default":{},"desc":"A set of input connectors for this node.","metatype":"dict"},"_meta_out_connectors":{"category":"General","default":{},"desc":"A set of output connectors for this node.","metatype":"dict"},"in_connectors":{"IN_Y":null},"out_connectors":{"OUT_Y":null}},"id":13,"label":"multiplication[i=0:N/2]","scope_entry":"12","scope_exit":"13","type":"MapExit"},{"attributes":{"_meta_code":{"category":"General","default":{"language":"Python","string_data":""},"desc":"Tasklet code","metatype":"CodeBlock"},"_meta_debuginfo":{"category":"General","default":{"end_column":0,"end_line":0,"filename":null,"start_column":0,"start_line":0,"type":"DebugInfo"},"desc":"","metatype":"DebugInfo"},"_meta_environments":{"category":"General","default":[],"desc":"Environments required by CMake to build and run this code node.","metatype":"set"},"_meta_in_connectors":{"category":"General","default":{},"desc":"A set of input connectors for this node.","metatype":"dict"},"_meta_instrument":{"category":"General","default":"No_Instrumentation","desc":"Measure execution statistics with given method","metatype":"InstrumentationType"},"_meta_label":{"category":"General","default":"","desc":"Name of the CodeNode","metatype":"str"},"_meta_location":{"category":"General","default":{},"desc":"Full storage location identifier (e.g., rank, GPU ID)","metatype":"dict"},"_meta_out_connectors":{"category":"General","default":{},"desc":"A set of output connectors for this node.","metatype":"dict"},"code":{"language":"Python","string_data":"out2 = ((in_A2 * in_X2) + in_Y2)"},"debuginfo":{"end_column":8,"end_line":30,"filename":"/var/folders/fh/hmjqvm896lq967r6bq0kfnjc0000gn/T/tmplp5hl0c4/fake.py","start_column":4,"start_line":24,"type":"DebugInfo"},"environments":[],"in_connectors":{"in_A2":null,"in_X2":null,"in_Y2":null},"instrument":"No_Instrumentation","label":"multiplication","location":{"gpu":"1"},"out_connectors":{"out2":null}},"id":14,"label":"multiplication","scope_entry":"12","scope_exit":"13","type":"Tasklet"},{"attributes":{"_meta_access":{"category":"General","default":"ReadWrite","desc":"Type of access to this array","metatype":"AccessType"},"_meta_data":{"category":"General","default":null,"desc":"Data (array, stream, scalar) to access","metatype":"DataProperty"},"_meta_debuginfo":{"category":"General","default":{"end_column":0,"end_line":0,"filename":null,"start_column":0,"start_line":0,"type":"DebugInfo"},"desc":"","metatype":"DebugInfo"},"_meta_in_connectors":{"category":"General","default":{},"desc":"A set of input connectors for this node.","metatype":"dict"},"_meta_out_connectors":{"category":"General","default":{},"desc":"A set of output connectors for this node.","metatype":"dict"},"_meta_setzero":{"category":"General","default":false,"desc":"Initialize to zero","metatype":"bool"},"access":"ReadWrite","data":"nested_slice_X_8_gpu_Y_0","debuginfo":{"end_column":0,"end_line":208,"filename":"/Users/Thomas/Documents/eth/2020hs/thesis/dace/dace/transformation/helpers.py","start_column":0,"start_line":208,"type":"DebugInfo"},"in_connectors":{},"out_connectors":{},"setzero":false},"id":15,"label":"nested_slice_X_8_gpu_Y_0","scope_entry":null,"scope_exit":null,"type":"AccessNode"}],"scope_dict":{"6":[7,8],"12":[13,14],"-1":[0,1,2,3,4,5,6,9,10,11,12,15]},"type":"SDFGState"}],"sdfg_list_id":0,"type":"SDFG"}